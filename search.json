[{"title":"深入理解ArrayList","url":"/2020/04/06/深入理解ArrayList/","content":"\n## 底层实现\n\n> ArrayList底层是由默认容量大小为10的Object数组实现\n<!-- more -->\n\n```java\n    /**\n     * Default initial capacity.\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * Shared empty array instance used for empty instances.\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /*\n     * Shared empty array instance used for default sized empty instances.\n\t */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /*\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n\t */\n    private int size;\n```\n\nDEFAULT_CAPACITY： 默认初始化容量\n\nEMPTY_ELEMENTDATA：空数组对象，创建ArrayList构造函数初识容量为0时,默认对象内容为该对象\n\n```java\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\nDEFAULTCAPACITY_EMPTY_ELEMENTDATA：空数组对象，如果使用默认构造函数创建，则默认对象内容则为该对象\n\n```java\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n\nelementData：数据存储对象\n\nsize：当前数组长度\n\n\n\n## 添加元素\n\nArrayList主要提供`add`、`addAll`、`set`等方法来实现元素的添加。\n\n### add(E element)\n\n```java\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        // 数组初始化 or 扩容处理\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n添加元素到数组最末处；\n\n#### ensureCapacityInternal(minCapacity)\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n        // 如果elementData 指向的是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的地址\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            //置默认大小 为DEFAULT_CAPACITY\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        //确定实际容量\n        ensureExplicitCapacity(minCapacity);\n    }\n\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // 如果超出了容量，进行扩展\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n\n对当前数组对象的一些动态处理\n\n#### 扩容 grow(int minCapacity)\n\n```java\n\tprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        //右移运算符等价于除以2，如果第一次是10，扩容之后的大小是15\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n使用Arrays.copyOf方法将当前数据的元素复制到一个为当前数组容量1.5倍大小的新数组中\n\n### add(int index, E element)\n\n插入元素到当前数组指定下标处\n\n```java\n    /**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index); // 1\n\n        ensureCapacityInternal(size + 1); // 2 // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index); // 3\n        elementData[index] = element; // 4\n        size++; // 5\n    }\n```\n\n结合源码解读添加流程：\n\n1. 判断当前索引是否数组越界，如果超出则抛出IndexOutOfBoundsException异常\n2. 对数组动态处理; 初始化 or 扩容\n3. 将旧数组拷贝到一个新数组中，参数：被复制的原数组, 被复制数组的第几个元素开始复制, 复制的目标数组, 从目标数组index + 1位置开始粘贴, 复制的元素个数\n4. 将元素添加到指定下标处\n5. 数组长度+1\n\n### addAll(int index, Collection<? extends E> c)\n\n```java\n\tpublic boolean addAll(Collection<? extends E> c) {\n            /*转为对象数组*/\n            Object[] a = c.toArray();\n            int numNew = a.length;\n            /*扩容机制：判断是否需要扩容*/\n            ensureCapacityInternal(size + numNew);  // Increments modCount\n            /*拷贝数组，参数:被复制的数组，被复制数组的第几个元素开始复制，复制到目标数组，目标数组粘贴的位置， 复制的个数*/\n            System.arraycopy(a, 0, elementData, size, numNew);\n            /*数组长度+numNew*/\n            size += numNew;\n            return numNew != 0;\n        }\n```\n\nArrayList的addAll()方法的实现和add()方法实现思路一致，只不过需要移动的元素更多，由于数组结构的特性，导致这样的操作对于数据大的ArrayList的插入操作，\n\n会严重影响代码执行的效率，所以开发中我们应该尽量避免出现对数据元素多的ArrayList频繁add。\n\n### set(int index, E element)\n\n替换指定下标的元素\n\n```java\n    /**\n     * Replaces the element at the specified position in this list with\n     * the specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E set(int index, E element) {\n        rangeCheck(index); // 校验数组越界\n\n        E oldValue = elementData(index);// 插入下标处原元素\n        elementData[index] = element; // 将元素指向数组指定下标处\n        return oldValue;\n    }\n```\n\n\n\n## 获取元素\n\n### get(int index)\n\n```java\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        rangeCheck(index); // 校验是否数组越界\n\n        return elementData(index);\n    }\n```\n\n获取指定下标的元素；\n\n\n\n## 删除元素\n\nArrayList提供了`remove(int index)`、`remove(Object o)`、`clear()`、`removeAll（Collection c）`\n\n### remove(int index)\n\n```java\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        rangeCheck(index); // 1\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1; // 2\n        if (numMoved > 0) // 3\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved); \n        elementData[--size] = null; // 4 // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n\n解读流程： \n\n1. 校验数组越界\n2. 计算需要删除数据位置\n3. 判断删除是否元素最后一位，是则需要移动数组\n4. 数组末尾下标元素指向空，垃圾回收\n\n### remove(Object o)\n\n删除ArrayList中的值对象，其实和通过下标删除很相似，只是多了一个步骤，遍历底层数组elementData，通过equals()方法或 == （特殊情况下）来找到要删除的元素，获取其下标，调用remove(int index)一样的代码即可。\n\n```java\n/**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If the list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n     * (if such an element exists).  Returns <tt>true</tt> if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return <tt>true</tt> if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        if (o == null) { \n            for (int index = 0; index < size; index++) //遍历集合\n                // 判断数组对象与删除对象是否相等\n                // 如相等则调用fastRemove方法删除该下标元素\n                if (elementData[index] == null) { \n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n\t// 同remove(int index)\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n```\n\n\n\n### clear()\n\n集合清空，通过遍历底层数组elementData，设置为null\n\n```java\n    /**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */\n    public void clear() {\n        modCount++;\n\n        // clear to let GC do its work\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n```\n\n\n\n### removeAll（Collection c）\n\n删除不与传入集合对象相匹配的元素\n\n```java\n    /**\n     * Removes from this list all of its elements that are contained in the\n     * specified collection.\n     *\n     * @param c collection containing elements to be removed from this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws ClassCastException if the class of an element of this list\n     *         is incompatible with the specified collection\n     * (<a href=\"Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if this list contains a null element and the\n     *         specified collection does not permit null elements\n     * (<a href=\"Collection.html#optional-restrictions\">optional</a>),\n     *         or if the specified collection is null\n     * @see Collection#contains(Object)\n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c); //  空对象校验\n        return batchRemove(c, false);\n    }\n\n    private boolean batchRemove(Collection<?> c, boolean complement) {\n        final Object[] elementData = this.elementData; // 获取当前集合数组\n        int r = 0, w = 0;\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                // 判断元素是否存在传入集合中\n                // 不存在则将该元素放入数组中，从下标0开始存放\n                if (c.contains(elementData[r]) == complement) \n                    elementData[w++] = elementData[r];\n        } finally {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            // 判断当前数组是否有更改\n            // 有更改则移动数组元素\n            if (r != size) { \n                System.arraycopy(elementData, r,\n                                 elementData, w,\n                                 size - r);\n                w += size - r;\n            }\n            // 判断数组是否有移动\n            // 如果有移动则将多余元素下标指向null\n            if (w != size) {\n                // clear to let GC do its work\n                for (int i = w; i < size; i++)\n                    elementData[i] = null;\n                modCount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n```\n\n\n\n## 总结\n\n- ArrayList底层由数组组成，数组是适合查询的，因为数组每个元素的内存空间是固定的，但是增删元素都需要复制一个新的数组，随着数组越来越大，效率会越发低下；\n\n- arraylist不是线程安全的,只能用在单线程环境下\n\n- arraylist支持序列化和克隆\n- ArrayList适合频繁查询的业务场景，而频繁增删的场景更适合使用linkedList"},{"title":"深入理解LinkedList","url":"/2020/04/06/深入理解LinkedList/","content":"\n## 底层实现\n\n> 一个双向链表实现的List，它除了作为List使用，还可以作为队列或者堆栈使用\n>\n> 在链表首尾添加元素很高效，在中间添加元素比较低效，首先要找到插入位置的节点，在修改前后节点的指针。<!-- more -->\n\n核心成员变量\n\n```java\n\ttransient int size = 0; // 指向当前集合大小\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first; // 指向当前集合第一个节点\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last; // 指向当前集合最末节点\n```\n\n`transient`关键字(引用百度百科)： \n\n> Java语言的关键字，变量修饰符，如果用**transient**声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用**transient**关键字标记的成员变量不参与序列化过程。\n\n内部Node节点\n\n```java\n \tprivate static class Node<E> {\n        E item; // 当前节点\n        Node<E> next; // 指向下一节点\n        Node<E> prev; // 指向上一节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n\n\n\n## 添加元素\n\nLinkedList主要提供`addFirst`、`addLast`、`add`、`addAll`等方法来实现元素的添加。\n\n### add()\n\n```java\n \tpublic void add(int index, E element) {\n        checkPositionIndex(index); // 1\n\n        if (index == size) // 2\n            linkLast(element);\n        else // 3\n            linkBefore(element, node(index));\n    }\n```\n\n执行流程：\n\n1. 判断是否越界\n2. 当前index等于节点个数，就将元素添加到链表尾部\n3. 添加当前元素到指定节点前\n\n```java\n    void linkLast(E e) {\n        //将内部保存的尾节点赋值给l\n        final Node<E> l = last;\n        //创建新节点，新节点的prev节点是当前的尾节点\n        final Node<E> newNode = new Node<>(l, e, null);\n        //把新节点作为新的尾节点\n        last = newNode;\n        //判断是否是第一个添加的元素\n        //如果是将新节点赋值给first\n        //如果不是把原首节点的next设置为新节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        //更新链表节点个数\n        size++;\n        //将集合修改次数加1\n        modCount++;\n    }\n\n```\n\n```java\n\t//将元素插入到指定节点前\n    void linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        //拿到succ的上一节点\n        final Node<E> pred = succ.prev;\n        //创建新节点\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        //将新节点作为succ的上一节点\n        succ.prev = newNode;\n        //判断succ是否是首节点\n        //如果是将新节点作为新的首节点\n        //如果不是将新节点作为pred的下一节点\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        //更新链表节点个数\n        size++;\n        //将集合修改次数加1\n        modCount++;\n    }\n```\n\n### addFirst()\n\n添加元素至链表头节点\n\n```java\n    public void addFirst(E e) {\n        linkFirst(e);\n    }\n\n    /**\n     * Links e as first element.\n     */\n    private void linkFirst(E e) {\n        final Node<E> f = first; // 获取当前头部节点\n        final Node<E> newNode = new Node<>(null, e, f); // 当前元素创建新节点\n        first = newNode; // 头部节点指向新节点\n        \n        //判断是否是第一个添加的元素\n        //如果是将新节点赋值给last\n        //如果不是把原首节点的prev设置为新节点\n        if (f == null) \n            last = newNode;\n        else\n            f.prev = newNode;\n        \n        size++; // 更新链表节点个数\n        modCount++; // 集合修改次数+1\n    }\n```\n\n### addLast()\n\n添加元素至链表尾节点\n\n```java\n    public void addLast(E e) {\n        linkLast(e);\n    }\n\n    /**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last; // 获取当前尾结点元素\n        final Node<E> newNode = new Node<>(l, e, null); // 为当前元素创建新节点\n        last = newNode; // 尾部节点指向新节点\n        \n        // 判断是否为第一个添加的元素\n        // 如果是则将first指向新节点\n\t\t// 如果不是则把原尾结点的next指向为新节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        \n        size++; // 更新链表节点个数\n        modCount++; // 集合修改次数+1\n    }\n```\n\n### addAll()\n\n```java\n\t//将集合内的元素依次插入index位置后\n    public boolean addAll(int index, Collection<? extends E> c) {\n        //判断是否越界\n        checkPositionIndex(index);\n\t\t//将集合转换为数组\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        //判断数组长度是否为0，为0直接返回false\n        if (numNew == 0)\n            return false;\n\t\t//pred上一个节点，succ当前节点\n        Node<E> pred, succ;\n        //判断index位置是否等于链表元素个数\n        //如果等于succ赋值为null，pred赋值为当前链表尾节点last\n        //如果不等于succ赋值为index位置的节点，pred赋值为succ的上一个节点\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\t\t//循环数组\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果上一个节点为null，把新节点作为新的首节点，否则pred的下一个节点为新节点\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            //把新节点赋值给上一个节点\n            pred = newNode;\n        }\n\t\t//如果index位置的节点为null，把pred作业尾节点\n        //如果不为null，pred的下一节点为index位置的节点，succ的上一节点为pred\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\t\t//更新链表节点个数\n        size += numNew;\n        //将集合修改次数加1\n        modCount++;\n        //因为是无界的，所以添加元素总是会成功\n        return true;\n    }\n```\n\n\n\n## 获取元素\n\n> LinkedList提供了`get`、`getFirst`、`getLast`等方法获取节点元素值。\n\n### get()\n\n获取指定位置的元素\n\n```java\n\t//获取指定位置的元素值\n    public E get(int index) {\n        //判断是否越界\n        checkElementIndex(index);\n        //直接调用node方法获取指定位置的节点，并反回其元素值\n        return node(index).item;\n    }\n\n\t/**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        // 判断当前索引是否处于链表前段\n        // 如果是则从头部开始遍历获取元素\n        // 如果不是则从尾部开始遍历获取元素\n        if (index < (size >> 1)) {\n            Node<E> x = first; // 获取当前头部节点\n            for (int i = 0; i < index; i++) // 根据索引从头部开始遍历节点\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last; // 获取当前尾部节点\n            for (int i = size - 1; i > index; i--) //根据索引从尾部开始遍历\n                x = x.prev;\n            return x;\n        }\n    }\n\n```\n\n### getFirst()\n\n返回当前链表头部元素\n\n```java\n    /**\n     * Returns the first element in this list.\n     *\n     * @return the first element in this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\n\n```\n\n\n\n### getLast()\n\n返回当前链表尾部元素\n\n```java\n    /**\n     * Returns the last element in this list.\n     *\n     * @return the last element in this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n\n```\n\n\n\n## 关于队列的操作\n\nLinkedList可以作为FIFO(First In First Out)的队列，也就是先进先出的队列使用，以下是关于队列的操作。\n\n```java\n    //获取队列的第一个元素，如果为null会返回null\n    public E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\t//获取队列的第一个元素，如果为null会抛出异常\n    public E element() {\n        return getFirst();\n    }\n\t//获取队列的第一个元素，如果为null会返回null\n    public E poll() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n\n\t//获取队列的第一个元素，如果为null会抛出异常\n    public E remove() {\n        return removeFirst();\n    }\n\t//将元素添加到队列尾部\n    public boolean offer(E e) {\n        return add(e);\n    }\n\n```\n\n## 关于双端队列操作\n\n双端列队可以作为栈使用，栈的特性是LIFO(Last In First Out)，也就是后进先出。所以作为栈使用也很简单，添加和删除元素都只操作队列的首节点即可。\n\n```java\n//将元素添加到首部\n    public boolean offerFirst(E e) {\n        addFirst(e);\n        return true;\n    }\n\t//将元素添加到尾部\n    public boolean offerLast(E e) {\n        addLast(e);\n        return true;\n    }\n \t//获取首部的元素值\n    public E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n\t//获取尾部的元素值\n    public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n\t//删除首部，如果为null会返回null\n    public E pollFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n\t//删除尾部，如果为null会返回null\n    public E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n\t//将元素添加到首部\n    public void push(E e) {\n        addFirst(e);\n    }\n\t//删除首部，如果为null会抛出异常\n    public E pop() {\n        return removeFirst();\n    }\n\t//删除链表中元素值等于o的第一个节点，其实和remove方法是一样的，因为内部还是调用的remove方法\n    public boolean removeFirstOccurrence(Object o) {\n        return remove(o);\n    }\n\n\t//删除链表中元素值等于o的最后一个节点\n\tpublic boolean removeLastOccurrence(Object o) {\n     \t//因为LinkedList允许存在null，所以需要进行null判断\n        if (o == null) {\n            //和remove方法的区别它是从尾节点往前遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (x.item == null) {\n                    //调用unlink方法删除指定节点\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n```\n\n\n\n","tags":["java","源码","LinkedList"],"categories":["数据结构"]},{"title":"深入理解ConcurrentHashMap","url":"/2020/04/05/深入理解ConcurrentHashMap/","content":"\n## Base1.7\n\njdk1.7中concurrentHashMap由Segment数组，HashEntry组成，和HashMap一样,是数组加链表的组成结构。\n\n### 组成\n\n核心成员<!-- more -->变量：\n\n```java\n\t/**\n     * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。\n     */\n    final Segment<K,V>[] segments;\n\n    transient Set<K> keySet;\n    transient Set<Map.Entry<K,V>> entrySet;\n```\n\nSegment是ConcurrentHashMap的内部类，主要组成如下：\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable {\n\n        private static final long serialVersionUID = 2249069246763182397L;\n        \n        // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶\n        transient volatile HashEntry<K,V>[] table;\n\n        transient int count;\n\n        transient int modCount;\n\n        transient int threshold;\n\n        final float loadFactor;\n        \n    }\n```\n\n重点看下HashEntry组成：\n\n```java\nstatic final class HashEntry<k,v>{\n    final int hash;\n    final K key;\n    volatile V value;\n    volatile HashEntry<k,V> next;\n}\n```\n\n和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。\n\n原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。\n\n\n\n### put()\n\n```java\npublic V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n        int hash = hash(key);\n        int j = (hash >>> segmentShift) & segmentMask;\n        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n            s = ensureSegment(j);\n        return s.put(key, hash, value, false);\n    }\n\n\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value); // 1 \n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) { // 2\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else { // 3\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock(); // 4\n            }\n            return oldValue;\n        }\n```\n\n虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。\n\n首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 `scanAndLockForPut()` 自旋获取锁。\n\n\n\n结合上面源码put流程：\n\n1. 将当前Segment中的table通过key的hashcode定位到HashEntry。\n2. 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。\n3. 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。\n4. 最后接触在步骤1中所获取当前Segment的锁\n\n### get()\n\n```java\npublic V get(Object key) {\n        Segment<K,V> s; // manually integrate access methods to reduce overhead\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return e.value;\n            }\n        }\n        return null;\n    }\n\n```\n\nget 逻辑比较简单：\n\n只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。\n\n由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。\n\nConcurrentHashMap 的 get 方法是非常高效的，**因为整个过程都不需要加锁**。\n\n\n\n## Base1.8\n\n1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。\n\n> 那就是查询遍历链表效率太低。\n\n因此 1.8 做了一些数据结构上的调整。\n\n### 优化\n\n1.8 抛弃了原有的 Segment 分段锁，而采用了 `CAS + synchronized` 来保证并发安全性。也将1.7中的数据节点由HashEntry改为了Node,但是其作用都是相同的。\n\n```java\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        volatile V val;\n        volatile Node<K,V> next;\n\n        Node(int hash, K key, V val, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.val = val;\n            this.next = next;\n        }\n```\n\n其中的 `val next` 都用了 volatile 修饰，保证了可见性。\n\n### put()\n\n```java\n\tpublic V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n\n/** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) { // 1\n            Node<K,V> f; int n, i, fh;\n            if (tab == null || (n = tab.length) == 0)  // 2\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 3\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            else if ((fh = f.hash) == MOVED) // 4\n                tab = helpTransfer(tab, f);\n            else {\n                V oldVal = null;\n                synchronized (f) { // 5\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD) // 6\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n```\n\n结合源码查看put流程\n\n1. 根据 key 计算出 hashcode 。\n2. 判断是否需要进行初始化。\n3. `f` 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。\n4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。\n5. 如果都不满足，则利用 synchronized 锁写入数据。\n6. 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。\n\n> 1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（`O(logn)`），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。\n\n\n\n### get()\n\n```java\npublic V get(Object key) {\n        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n        int h = spread(key.hashCode());\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n            if ((eh = e.hash) == h) {\n                if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                    return e.val;\n            }\n            else if (eh < 0)\n                return (p = e.find(h, key)) != null ? p.val : null;\n            while ((e = e.next) != null) {\n                if (e.hash == h &&\n                    ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                    return e.val;\n            }\n        }\n        return null;\n    }\n```\n\n- 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。\n- 如果是红黑树那就按照树的方式获取值。\n- 就不满足那就按照链表的方式遍历获取值。\n\n> 1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（`O(logn)`），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。\n\n","tags":["java","ConcurrentHashMap","源码"],"categories":["数据结构"]},{"title":"深入理解HashMap","url":"/2020/04/05/深入理解HashMap/","content":"\n## jdk1.7与1.8区别\n\n### Base1.7\n\n使用数据结构是数组加链表，数据节点是使用的entry(内部类)节点；\n<!-- more -->\n```java\n/** \n * Entry类实现了Map.Entry接口\n * 即 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法\n**/  \nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;  // 键\n    V value;  // 值\n    Entry<K,V> next; // 指向下一个节点 ，也是一个Entry对象，从而形成解决hash冲突的单链表\n    int hash;  // hash值\n  \n    /** \n     * 构造方法，创建一个Entry \n     * 参数：哈希值h，键值k，值v、下一个节点n \n     */  \n    Entry(int h, K k, V v, Entry<K,V> n) {  \n        value = v;  \n        next = n;  \n        key = k;  \n        hash = h;  \n    }  \n  \n    // 返回 与 此项 对应的键\n    public final K getKey() {  \n        return key;  \n    }  \n\n    // 返回 与 此项 对应的值\n    public final V getValue() {  \n        return value;  \n    }  \n  \n    public final V setValue(V newValue) {  \n        V oldValue = value;  \n        value = newValue;  \n        return oldValue;  \n    }  \n    \n   /** \n     * equals（）\n     * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  \n     */ \n      public final boolean equals(Object o) {  \n        if (!(o instanceof Map.Entry))  \n            return false;  \n        Map.Entry e = (Map.Entry)o;  \n        Object k1 = getKey();  \n        Object k2 = e.getKey();  \n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {  \n            Object v1 = getValue();  \n            Object v2 = e.getValue();  \n            if (v1 == v2 || (v1 != null && v1.equals(v2)))  \n                return true;  \n        }  \n        return false;  \n    }  \n    \n    /** \n     * hashCode（） \n     */ \n    public final int hashCode() { \n        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());  \n    }  \n  \n    public final String toString() {  \n        return getKey() + \"=\" + getValue();  \n    }  \n  \n    /** \n     * 当向HashMap中添加元素时，即调用put(k,v)时， \n     * 对已经在HashMap中k位置进行v的覆盖时，会调用此方法 \n     * 此处没做任何处理 \n     */  \n    void recordAccess(HashMap<K,V> m) {  \n    }  \n  \n    /** \n     * 当从HashMap中删除了一个Entry时，会调用该函数 \n     * 此处没做任何处理 \n     */  \n    void recordRemoval(HashMap<K,V> m) {  \n    } \n\n}\n```\n\n\n\n数据插入使用**头插法**：\n\n​\t缺点： 在扩容resize时会调用transfer方法，在transfer方法中把存在的entry节点做了一个rehash操作，在这个过程当中可能会再多线程情况下造成一个链表的循环，则可能会在下一次get的时候造成一个死循环；也有另外一个情况就是他对方法没有加锁，所以它也有可能在多个并发情况下，数据不能保证是安全的，也就是我put进去的值，取出来还是我put进去的那个值；\n\n```java\n1.7 transfer()方法\nvoid transfer(Entry[] newTable) {\n    Entry[] src = table; //src引用了旧的Entry数组\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组\n        Entry<K,V> e = src[j]; //取得旧Entry数组的每个元素\n        if (e != null) {\n            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n            do {\n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n                e.next = newTable[i]; //标记[1]\n                newTable[i] = e; //将元素放在数组上\n                e = next; //访问下一个Entry链上的元素\n            } while (e != null);\n        }\n    }\n}\n```\n\ntransfer方法由于使用的是单链表的头插法方式，同一位置上新元素总会放在链表的头部位置；这样先放在一个索引上的元素终会被放在entry链的尾部。在数组中同一条entry链上的元素，在重新计算索引位置后，有可能会放在了新数组的不同位置上\n\n\n\n### Base1.8\n\n使用的数据结构是数组加链表加红黑树，数据节点改使用为Node节点，也对put的过程做了一些优化;\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash; // hash值\n        final K key; // 键\n        V value; // 值\n        Node<K,V> next; // 指向下一个节点\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n\n\n\n优化过程： \n\n​\t对数据结构做了进一步的优化，引入了红黑树。而当判断当前链表长度>TREEIFY_THRESHOLD 时（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。\n\n\n\n\n\n## 扩容\n\n​\t\t首先需要了解capacity参数，在初始化hashmap的时候，如果我们没有设置capacity就会默认设置为默认值16来作为我们这个hashmap的容量，负载因子loadFactor为0.75，会根据这两个参数计算出一个threshold（阈值），在put时会判断当前这个size是不是大于这个阈值，如果大于时，他就会新创建一个2倍容量大小的一个数据，对旧的entry节点进行rehash的操作，将旧entry节点转移到新容器的这么一个resize的过程；\n\nresize()源码解释：\n\n```java\nvoid resize(int newCapacity) { //传入新的容量\n    Entry[] oldTable = table; //引用扩容前的Entry数组\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了\n    \tthreshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n    \treturn;\n\t}\n    Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组\n    transfer(newTable); //！！将数据转移到新的Entry数组里\n    table = newTable; //HashMap的table属性引用新的Entry数组\n    threshold = (int)(newCapacity * loadFactor);//修改阈值\n}\n这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\n\nvoid transfer(Entry[] newTable) {\n    Entry[] src = table; //src引用了旧的Entry数组\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组\n        Entry<K,V> e = src[j]; //取得旧Entry数组的每个元素\n        if (e != null) {\n            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n            do {\n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n                e.next = newTable[i]; //标记[1]\n                newTable[i] = e; //将元素放在数组上\n                e = next; //访问下一个Entry链上的元素\n            } while (e != null);\n        }\n    }\n}\n```\n\n\n\n\n\n## 疑问\n\n观察源码发现HashSet底层是new一个hashmap所实现的，那为什么还要保留HashSet呢","tags":["java","源码","HashMap"],"categories":["数据结构"]},{"title":"多线程高并发编程 - 线程池框架(三)","url":"/2019/11/24/多线程高并发编程-线程池框架/","content":"\n> 线程池：由系统维护的容纳线程的容器，由CLR控制的所有AppDomain共享。线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。\n<!-- more -->\n## Executor & ExecutorService\n\n### Executor\n\n首先我们来认识一下它`Excecutor[ɪɡˈzekjətə(r)] ` ,该接口是Java线程实现中的最顶层接口，通过传入一个 `Runnable`接口，由`Runnable`接口来定义一项执行任务，再交由 Executor.execute() 方法定义如何执行任务。\n\n```java\npackage c_026;\n\nimport java.util.concurrent.Executor;\n\npublic class T01_MyExecutor implements Executor {\n    @Override\n    public void execute(Runnable command) {\n        command.run();\n        // new Thread(command).star(); \n    }\n}\n\n```\n\n当然，此接口只需要了解并知道如何使用即可，毕竟在日常开发中Java给我们封装了极其多的线程池来供我们使用(^_^)。\n\n### ExecutorService\n\n该接口继承了`Executor`接口，`service` 一般都是后台线程,跑在后台提供服务，在这里呢它则代表执行器服务，`ExecutorService`就是这种线程，在启动后一直在后台等待任务并将其扔到容器中执行;\n\n既然该接口是继承于`Executor`接口，那么就代表该接口也具有execute 方法，并且还在其基础上添加了自已一些实现的封装方法，具体如下：\n\n> Future submit(Runnable): 提交Runnable任务以执行并返回表示该任务的Future。\n>\n> Future submit(Runnable, result): 提交可运行的任务以供执行并返回成功完成后返回给定结果。\n>\n> Future submit(Callable): 提交一个有返回值的callable任务,并将返回值作为future对象包装返回\n\n execute 和 submit 的区别:  没有本质区别,只不过execute只能执行Runnable接口;\n\n\n\n### Runnable & CallAble\n\n共同点： 接口都是设计出来给一个线程来调用的\n\n不同点：\n\n​\tRunnable的run()没有返回值，并且不能抛出异常！\n\n​\tCallable的call()方法具有返回值，并且可以抛出异常！\n\n\n\n### Executors\n\n> 用来操作Executor的工具类\n\nExecutors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。\n\n1、public static ExecutorService newFiexedThreadPool(int Threads) 创建固定数目线程的线程池。\n\n2、public static ExecutorService newCachedThreadPool()：创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。\n\n3、public static ExecutorService newSingleThreadExecutor()：创建一个单线程化的Executor。\n\n4、public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n\n创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。\n\n\n\n## ThreadPool\n\n> `ThreadPool`线程池,其内部维护了一堆线程执行任务，一般用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。\n\n用一个并行计算来演示线程池的作用，贴代码：\n\n```java\npackage c_026;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * 计算 1-200000 之间的质数\n */\npublic class T07_ParallelComputing {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        long start = System.currentTimeMillis();\n        List<Integer> result = getPrime(1, 20_0000);\n        long end = System.currentTimeMillis();\n        System.out.println(end - start); // 使用单线程计算的时间\n\n        ExecutorService service = Executors.newFixedThreadPool(4);\n        ComputeTask t1 = new ComputeTask(1, 8_0000);\n        ComputeTask t2 = new ComputeTask(8_0001, 13_0000);\n        ComputeTask t3 = new ComputeTask(13_0001, 17_0000);\n        ComputeTask t4 = new ComputeTask(17_0001, 20_0000);  // 这里为什么不均分? 因为数字越大, 质数的数量就越多\n        // 提交任务给ExecutorService执行\n        Future<List<Integer>> f1 = service.submit(t1);\n        Future<List<Integer>> f2 = service.submit(t2);\n        Future<List<Integer>> f3 = service.submit(t3);\n        Future<List<Integer>> f4 = service.submit(t4);\n        // 执行开始\n        start = System.currentTimeMillis();\n        f1.get();\n        f2.get();\n        f3.get();\n        f4.get();\n        end = System.currentTimeMillis();\n        System.out.println(end - start);\n        service.shutdown();\n    }\n    \n    static class ComputeTask implements Callable<List<Integer>> {\n\n        private int start, end;\n        \n        ComputeTask (int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        public List<Integer> call() throws Exception {\n            return getPrime(start, end);\n        }\n    }\n    \n    static boolean isPrime(int num) {\n        for (int i = 2; i < num / 2; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * 返回指定范围的质数列表\n     */\n    static List<Integer> getPrime(int start, int end) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < end; i++) {\n            if (isPrime(i)) list.add(i);\n        }\n        return list;\n    }\n}\n\n```\n\n运行结果(ps: 运行时长差距可能会因cpu单线程运算能力而有所误差)：\n\n```\n5300\n2829\n```\n\n### FixedThreadPool\n\n> 固定线程的线程池，在执行任务过程中，无须启动新的线程，如遇到所有线程都在执行状态下，空闲任务会在其内部维护的一个任务队列等待（BlockingQueue）;这样就让我们在处理任务时无须再多起线程来消耗系统多余的资源\n\n线程池中维护了两个任务队列：\n        1. 未执行的任务队列\n                2. 已执行的任务队列\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * ThreadPool \n * 线程池\n */\npublic class T05_ThreadPool {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ExecutorService service = Executors.newFixedThreadPool(5); // 固定长度的线程池\n        for (int i = 0; i < 6; i++) { // 执行六个任务,  在只有五个固定容量的线程池中\n            service.execute(() -> {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        System.out.println(service); // [Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]\n        // 内部一般是BlockingQueue\n        // pool size =  5  线程池的容量\n        // active thread = 5 激活的线程队列长度\n        // queued tasks = 1 等待处理任务长度\n        // completed task = 0 完成执行的任务数量\n        \n        // 关闭线程池\n        service.shutdown(); // 未执行完毕,不会停止,只会进入停止中状态\n        System.out.println(service.isTerminated()); // false 判断任务是否结束\n        System.out.println(service.isShutdown()); // true 判断线程池状态是否关闭\n        System.out.println(service);  //java.util.concurrent.ThreadPoolExecutor@3b9a45b3[Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]\n        \n\n        TimeUnit.SECONDS.sleep(5); // 5s 后肯定执行完成了\n\n        System.out.println(service.isTerminated()); // true \n        System.out.println(service.isShutdown()); // true\n        System.out.println(service); // java.util.concurrent.ThreadPoolExecutor@3b9a45b3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 6]\n   \n    }\n}\n```\n\n使用linkedBlockingQueue当容器\n\n### CatchedThreadPool\n\n> 可缓存的线程，弹性的\n\n当有个请求进入线程池内, 线程池将会启用一个线程。\n\n当再次有个请求进入线程池内, 并且上个线程未结束, 仍然会启用一个线程。\n\n当有线程执行完毕后,这个线程不会被清除, 而是被缓存,当有请求进入时, 直接使用缓存线程调用。\n\n跟 fixedThreadPool 类似, 只不过没有上限(最多Integer最大值), 是一种弹性操作。\n\n当线程一直不被使用, 缓存最多持续1分钟(AliveTime默认值),就会被线程池销毁。\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\npublic class T08_CachedThreadPool {\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newCachedThreadPool();\n        // pool size 为0\n        System.out.println(service); // java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]cu'\n\n        for (int i = 0; i < 2; i++) {\n            service.execute(() -> {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        // pool size 变为2 \n        System.out.println(service); // java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]\n\n\n        try {\n            TimeUnit.SECONDS.sleep(80); // 最多持续1分钟,这里sleep80s\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // pool size 变为0\n        System.out.println(service); // java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 2]\n\n    } \n}\n```\n\n\n\n### SingleThreadPool\n\n> 线程池中只有一个线程，作用:保证线程执行的时序性。\n\n使用场景：让任务按前后顺序执行；\n\n内部实现：由一个阻塞队列维护；\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * SingleThreadPool\n */\npublic class T09_SingleThreadPool {\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 5; i++) {\n            final int j = i;\n            service.execute(() -> {\n                System.out.println(j + \" \" + Thread.currentThread().getName());\n            });\n        }\n    } \n}\n\n```\n\n运行结果：\n\n```\n0 pool-1-thread-1\n1 pool-1-thread-1\n2 pool-1-thread-1\n3 pool-1-thread-1\n4 pool-1-thread-1\n```\n\n这个线程没什么好讲的，理解使用就好啦；\n\n### ScheduleThreadPool\n\n> Scheduled: 计划中的,定时的;\n>\n> 固定时间执行的线程池，一般用来做定时任务\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * ScheduledPool\n * 执行定时的任务,类似Delay, 可以替代Timer\n */\npublic class T10_ScheduledPool {\n\n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(4);\n        // 使用固定的频率执行某个任务\n        // 四个参数\n        // command: 执行的任务\n        // initialDelay: 第一次执行延时多久执行\n        // period: 每隔多久执行一次这个任务\n        // unit: 时间单位\n        service.scheduleAtFixedRate(() -> {\n            try {\n                TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName());\n        }, 0, 500, TimeUnit.MILLISECONDS);  // 每隔500ms打印一下线程名称\n        // 线程执行1000ms,而每sleep 500 就要新启动一个线程\n        // 上个线程未执行完毕,会启用新的线程执行\n        // 如果线程池已满,只有延时\n    } \n}\n```\n\n\n\n### WorkStealingThreadPool\n\n> 工作窃取线程池，启动的线程是后台线程(也称精灵线程,守护线程)，运行效果与FixedThreadPool差不多，区别就是FixedThreadPool启动的为普通线程，WorkStealingThreadPool启动的为 后台线程\n\n内部实现：\n\n```java\npublic static ExecutorService newWorkStealingPool() {\n    return new ForkJoinPool\n        (Runtime.getRuntime().availableProcessors(),\n         ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n         null, true);\n}\n```\n\n可以看出他的实现其实只是new了一个ForkJoinPool线程池，所以本质上其实与ForkJoinPool并没有什么区别，只是在其之上的一层封装，方便使用。\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * WorkStealingPool\n */\npublic class T11_WorkStealingPool {\n\n    public static void main(String[] args) throws IOException {\n        // CPU 核数\n        System.out.println(Runtime.getRuntime().availableProcessors());\n        \n        // workStealingPool 会自动启动cpu核数个线程去执行任务\n        ExecutorService service = Executors.newWorkStealingPool();\n        service.execute(new R(1000));  // 我的cpu核数为12 启动13个线程,其中第一个是1s执行完毕,其余都是2s执行完毕,\n                                                // 有一个任务会进行等待,当第一个执行完毕后,会再次偷取第十三个任务执行\n        for (int i = 0; i < Runtime.getRuntime().availableProcessors(); i++) {\n            service.execute(new R(2000));\n        }\n        \n        // 因为work stealing 是deamon线程,即后台线程,精灵线程,守护线程\n        // 所以当main方法结束时, 此方法虽然还在后台运行,但是无输出\n        // 可以通过对主线程阻塞解决\n        System.in.read();\n    }\n    \n    static class R implements Runnable {\n\n        int time;\n\n        R(int time) {\n            this.time = time;\n        }\n\n        @Override\n        public void run() {\n            try {\n                TimeUnit.MILLISECONDS.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"  \" + time);\n        }\n    }\n}\n\n```\n\n\n\n### ForkJoinPool\n\n> 将一个任务拆分多个任务执行(理论可以无限切分，递归),然后再将结果合并；\n>\n> 使用场景： 比如大量的并行计算, 如下: 求100_0000个数字之和, 使用多线程\n\nForkJoinPool执行的是ForkJoinTask，即RecursiveAction，RecursiveTask；\n\nRecursiveAction与RecursiveTask的区别就是RecursiveAction执行后没有返回值，反之RecursiveTask执行后有返回值。\n\n示例代码：\n\n```java\npackage c_026;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.*;\n\n/**\n * T12_ForkJoinPool\n */\npublic class T12_ForkJoinPool {\n\n    static int[] nums = new int[100_0000];\n    static final int MAX_NUM = 5_0000; // 每个线程最多可以运行5万个数字相加\n    static Random random = new Random();\n    \n    // 初始化这100_000个数字, 每个数字范围在100之内\n    static {\n        \n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = random.nextInt(100);\n        }\n        // 所有数字和, 事先计算:\n        //System.out.println(Arrays.stream(nums).sum()); // 使用单线程stream api 进行求和\n    }\n    \n\t/*\n\t* RecursiveAction任务\n\t*/\n    static class AddTask extends RecursiveAction {\n        \n        int start, end;\n        \n        AddTask(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        protected void compute() {\n            \n            // 进行计算\n            // 如果计算的数的和的范围 小于 MAX_NUM, 进行计算,否则进行 fork \n            if (end - start <= MAX_NUM) {\n                long sum = 0;\n                for (int i = start; i < end; i++) {\n                    sum += nums[i];\n                }\n                System.out.println(\"sum = \" + sum);\n            } else {\n                int middle = (end - start) / 2;\n                AddTask subTask1 = new AddTask(start, middle);\n                AddTask subTask2 = new AddTask(middle, end);\n                subTask1.fork();\n                subTask2.fork();\n            }\n        }\n    }\n    \n\t/*\n\t* RecursiveTask\n\t*/\n    static class AddTask2 extends RecursiveTask<Long> {\n\n        int start, end;\n        \n        AddTask2(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n        \n        @Override\n        protected Long compute() {\n            // 进行计算\n            // 如果计算的数的和的范围 小于 MAX_NUM, 进行计算,否则进行 fork \n            if (end - start <= MAX_NUM) {\n                long sum = 0;\n                for (int i = start; i < end; i++) {\n                    sum += nums[i];\n                }\n                return sum;\n            } else {\n                int middle = start + (end - start) / 2; // 注意这里，如果有问题，会抛出java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node 异常\n                AddTask2 subTask1 = new AddTask2(start, middle);\n                AddTask2 subTask2 = new AddTask2(middle, end);\n                subTask1.fork();\n                subTask2.fork();\n                return subTask1.join() + subTask2.join();\n            }\n        }\n    }\n\n    // 运行\n    public static void main(String[] args) throws IOException {\n        ForkJoinPool fjp = new ForkJoinPool();\n        AddTask2 task = new AddTask2(0, nums.length);\n        fjp.execute(task);\n        System.out.println(task.join());        \n        //System.in.read();\n    }\n\n}\n```\n\n\n\n### ThreadPoolExecutor\n\n> 自定义线程池，线程池的实现原理，除了ForkJoinPool与WorkStealingPool线程池，其他线程池大部分线程池背后都是ThreadPoolExecutor\n\n**构造 ThreadPoolExecutor:** \n\n​\tcorePoolSize            线程池核心线程数，最小线程数\n\n​\tmaximumPoolSize         最大线程数\n\n​\tkeepAlive               线程空闲后存活时间， 0代表永远不会消失\n\n​\ttimeUnit                单位\n\n​\tBlockingQueue workQueue 任务容器具体查看每个线程池\n\n\n\n**举个栗子：**\n\n SingleThreadPool创建实现,内部是由ThreadPoolExecutor来创建的。\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n其他几个就不都一一介绍了，可以自己去查看源码实现。。。\n\n\n\n### parallelStreamAPI\n\n> Java8的新增特性\n>\n> 平行流API,运用多线程的流API.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.\n\n还是用质数运算举例，来感受下效果，示例代码如下：\n\n```java\npackage c_026;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class T14_ParallelStreamAPI {\n\n    public static void main(String[] args) {\n\n        List<Integer> nums = new ArrayList<>();\n        Random random = new Random();\n        for (int i = 0; i < 1_0000; i++) {\n            nums.add(100_0000 + random.nextInt(100_0000));\n        }\n\n        long start, end;\n\n        start = System.currentTimeMillis();\n        nums.stream().forEach(v -> isPrime(v));\n        end =System.currentTimeMillis();\n        \n        System.out.println(end - start);\n        \n        // 使用parallel stream api\n        start = System.currentTimeMillis();\n        nums.parallelStream().forEach(v -> isPrime(v));\n        end =System.currentTimeMillis();\n\n        System.out.println(end - start);\n    }\n    static boolean isPrime(int num) {\n        for (int i = 2; i < num / 2; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}\n```\n\n运行结果：\n\n```java\n1511\n675\n```\n\n\n\n## 总结\n\n莫道君行早，更有早行人。\n\n此博文是本人对于多线程学习之余的一些总结....如有什么错误麻烦请及时指教，在此提前谢过！另外学习资料来源于马士兵老师的多线程编程系列,有兴趣的可以自行去瞧瞧哦（^_^）\n\n本文项目地址：[https://github.com/xf616510229/java-concurrent](https://github.com/xf616510229/java-concurrent)","tags":["多线程"],"categories":["concurrent"]},{"title":"多线程高并发编程 - 并发容器(二)","url":"/2019/08/13/高并发编程学习-并发容器/","content":"\n> 本篇主要总结了：线程安全的单例模式和并发容器。其中并发容器包含：ConcurrentHashMap、ConcurrentSkipListMap、CopyOnWriteArrayList和队列相关的内部加锁的并发队列ConcurrentLinkedQueue 以及阻塞队列BlockingQueue （LinkedBlockingQueue、ArrayBlockingQueue 、DelayQueue 、TransferQueue、SynchronizedQueue ）\n\n<!-- more -->\n\n\n\n## 线程安全的单例模式\n\n### 不使用同步锁\n\n```java\npackage c_023;\npublic class Singleton1 {\n\n    //初识话一个示例对象\n    private static Singleton1 singleton1 = new Singleton1();\n\n    //private 类型的构造函数，保证其他对象不能直接new一个该对象示例\n    private Singleton1() {\n\n    }\n\n    /**\n     * 该类唯一的一个public方法\n     * @return\n     */\n    public static Singleton1 getInstance(){\n        return singleton1;\n    }\n}\n```\n\n缺点： 该类加载时会直接new一个静态对象，当一个系统中这样的类较多时，会使得启动速度变慢。\n\n现在流行的设计都是将“延迟加载”，这样我们可以在第一次使用时才初始化该类对象。\n\n所以这种方式只适合在小系统使用。\n\n### 使用同步锁\n\n```java\npackage c_023;\npublic class Singleton2 {\n    private static Singleton2 singleton2;\n\n    /**\n     * private 修饰构造方法\n     */\n    private  Singleton2() {\n\n    }\n\n    /**\n     * 使用 synchronized 修饰该方法，保证只有一个线程能够构建一个实例对象\n     * @return\n     */\n    public static synchronized Singleton2 getInstance(){\n        if(singleton2 == null){\n            singleton2 = new Singleton2();\n        }\n        return singleton2;\n    }\n}\n```\n\n缺点： 一次锁住了一个方法， 这个粒度有点大\n\n改进： 只锁住其中的new语句就OK。就是所谓的“双重锁”机制。\n\n### 使用双重同步锁\n\n```java\npackage c_023;\npublic class Singleton3 {\n    private static Singleton3 singleton3;\n\n    private Singleton3() {\n    }\n\n    /**\n     * 对获取示例的方法进行同步\n     * @return\n     */\n    public static Singleton3 getInstance(){\n        if(singleton3 == null){\n            synchronized (Singleton3.class){\n                if(singleton3 == null){\n                    singleton3 = new Singleton3();\n                }\n            }\n        }\n        return singleton3;\n    }\n}\n```\n\n### 内部类实现\n\n```java\npackage c_023;\n\npublic class Singleton {\n    \n    private Singleton() {\n    }\n    \n    private static class Inner {\n        private static Singleton s = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return Inner.s;\n    }\n    \n}\n```\n\n更好的是采用这种方式，既不用加锁，也能实现懒加载\n\n[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_023部分 \n\n\n\n## 并发容器\n\n### map/set相关\n\n#### 不加锁\n\nHashMap\n\nTreeMap\n\nLinkedHashMap\n\n\n\n#### 加锁且并发性不是特别高\n\n##### collect.synchronizedXXX()\n\n> 提供一系列方法给容器添加锁\n\n```java\npackage c_025;\n\npublic class CollectionsSychronizedXX {\n\n    public static void main(String[] args) {\n        Map map = new HashMap(); //创建一个容器\n        Map synchronizedMap = Collections.synchronizedMap(map); //调用方法给map加锁\n    }\n}\n\n```\n\n##### Hashtable\n\n> 所有实现都是带锁的 \n\n\n\n#### 加锁且并发性比较高\n\n##### ConcurrentHashMap\n\n> 使用分段锁，多线程情况下效率比Hashtable高\n\n容器被分为16段。多个线程可以同时并发的往里面插入数据，所以在多线程情况下，效率会比`HashTable`高\n\n\n\n#### 加锁且并发性比较高要求排序\n\n##### ConcurrentSkipListMap(并发跳表容器)\n\n> 高并发，并且需要排序的情况下\n\n\n\n#### 效率比较代码：\n\n```java\npackage c_025;\n/**\n * skipMap: https://blog.csdn.net/sunxianghuang/article/details/52221913\n */\npublic class T01_ConcurrentMap {\n\n    public static void main(String[] args) {\n\n        //Map<String, String> map = new HashMap<>(); \n        //Map<String, String> map = new Hashtable<>(); // 423  每次加锁，都锁一个对象\n        //Map<String, String> map = new ConcurrentHashMap<>(); // 309，加的是分段所，将容器分为16段，每段都有一个锁 segment; 1.8以后 使用 Node + synchronized+CAS\n        Map<String, String> map = new ConcurrentSkipListMap<>(); // 317  并发且排序，插入效率较低，但是读取很快\n        Random r = new Random();\n        Thread[] ths = new Thread[100];\n        CountDownLatch latch = new CountDownLatch(ths.length); // 启动了一个门闩，每有一个线程退出，门闩就减1，直到所有线程结束，门闩打开，主线程结束\n        \n        long start = System.currentTimeMillis();\n        // 创建100个线程，每个线程添加10000个元素到map，并启动这些线程\n        for (int i = 0; i < ths.length; i++) {\n            ths[i] = new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    map.put(\"a\" + r.nextInt(10000), \"a\" + r.nextInt(100000));\n                }\n                latch.countDown();\n            }, \"t\" + i);\n        }\n        Arrays.asList(ths).forEach(Thread::start);\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        long end = System.currentTimeMillis();\n        System.out.println(end - start);\n        System.out.println(map.size());\n    }\n    \n}\n```\n\n### 队列相关\n\n#### 同步队列\n\n##### ConcurrentLinkedQueue\n\n> LinkedQueue 无界队列，\n\noffer(): 插入值时并不会抛出异常，会通过boolean类型的返回值告诉你是否插入成功\n\npoll(): 将头值取出来并删除\n\npeek(): 将第一个值取出来并且不删除 \n\n```java\npackage c_025;\n\n/**\n * 同步队列，ConcurrentQueue\n */\npublic class T04_ConcurrentQueue {\n\n\n    public static void main(String[] args) {\n        Queue<String> queue = new ConcurrentLinkedQueue<>(); // LinkedQueue，无界队列\n\n        for (int i = 0; i < 10; i++) {\n            queue.offer(\"a\" + i); // 有返回值，返回false代表没有加入成功，true 代表成功，并且此方法不会阻塞\n        }\n\n        System.out.println(queue);\n        System.out.println(queue.size());\n\n        System.out.println(queue.poll()); // 取出队头\n        System.out.println(queue.size());\n\n        System.out.println(queue.peek()); // 取出队头，但是不删除队头\n        System.out.println(queue.size());\n    }\n    \n}\n\n```\n\n结果：\n\n```java\n[a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]\n10\na0 //去除内容并且删除\n9\na1 //只是取出内容\n9\n```\n\n##### BlockingQueue（阻塞式队列）\n\nput():  如果满了，线程就会等待\n\ntake(): 如果空了，线程就会等待\n\n###### linkedBlokingQueue\n\n> 无界队列\n\n示例代码：\n\n```java\npackage c_025;\n\npublic class T05_LinkedBlockingQueue {\n\n    public static void main(String[] args) {\n        BlockingQueue<String> queue = new LinkedBlockingQueue<>();\n\n        // 启动生产者线程生产\n        new Thread(() -> {\n            for (int j = 0; j < 100; j++) {\n                try {\n                    queue.put(\"aaa\" + j); // put 方法，给容器添加元素，如果容器已经满了，则会阻塞等待\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"p\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 启用消费者线程消费\n        for (int i = 0; i < 5; i++) {\n            new Thread(() -> {\n                while (true) {\n                    try {\n                        System.out.println(Thread.currentThread().getName() + \":\" + queue.take()); // 从队列中拿数据，如果空了，则会阻塞等待\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }, \"c\" + i).start();\n        }\n\n    }\n\n}\n```\n\n###### ArrayBlockingQueue\n\n> 有界队列\n\n示例代码：\n\n```java\npackage c_025;\n/**\n * 使用阻塞有界同步队列 ArrayBlockingQueue 完成生产者消费者模式\n */\npublic class T06_ArrayBlockingQueue {\n    public static void main(String[] args) throws InterruptedException {\n\n        BlockingQueue queue = new ArrayBlockingQueue<>(10);//初识10个容量队列\n\n        for (int i = 0; i < 10; i++) {\n            queue.put(\"a\" + i);\n        }\n\n        //queue.put(\"a11\"); // 会阻塞\n        //queue.add(\"a11\"); // 会抛出异常\n        //System.out.println(queue.offer(\"a11\")); // 会返回false\n        System.out.println(queue.offer(\"a11\", 1, TimeUnit.SECONDS)); // 会等待1s,返回false, 如果1s内有空闲,则添加成功后返回true\n    }\n}\n\n```\n\n##### DelayQueue（延迟队列）\n\n> 是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中\n>\n> 出队有个时间限制, 每个元素有一个等待时间, 可以按照等待时间排序元素DelayQueue元素必须为 Delayed类型的,即必须设置元素的等待时间\n\n可以用来做定时任务：\n\n```java\npackage c_025;\n\npublic class T07_DelayQueue {\n\n    /**\n    * 定时类\n    */\n    static class MyTask implements Delayed {\n        private long runningTime;\n\n        public MyTask(long runTime) {\n            this.runningTime = runTime;\n        }\n        \n        // 这是每个元素的等待时间, 越是后加入的元素,时间等待的越长\n        @Override\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        // 这是排序规律, 执行等待时间最短的排在上面\n        @Override\n        public int compareTo(Delayed o) {\n            return (int) (o.getDelay(TimeUnit.MILLISECONDS) - this.getDelay(TimeUnit.MILLISECONDS));\n        }\n        \n        @Override\n        public String toString() {\n            return runningTime + \"\";\n        }\n    }\n\n    \n    public static void main(String[] args) throws InterruptedException {\n        long timestamp = System.currentTimeMillis();\n        MyTask myTask1 = new MyTask(timestamp + 1000); // 1s后执行\n        MyTask myTask2 = new MyTask(timestamp + 2000);\n        MyTask myTask3 = new MyTask(timestamp + 1500);\n        MyTask myTask4 = new MyTask(timestamp + 2500);\n        MyTask myTask5 = new MyTask(timestamp + 500);\n\n        DelayQueue<MyTask> tasks = new DelayQueue<>();\n        tasks.put(myTask1);\n        tasks.put(myTask2);\n        tasks.put(myTask3);\n        tasks.put(myTask4);\n        tasks.put(myTask5);\n\n        System.out.println(tasks);  // 确实按照我们拍的顺序执行的\n\n        for (int i = 0; i < tasks.size(); i++) {\n            System.out.println(tasks.take());\n        }\n    }\n}\n```\n\n结果：\n\n```java\n[1565690284606, 1565690284106, 1565690283606, 1565690283106, 1565690282606]\n1565690284606 //按插入顺序取 \n1565690284106\n1565690283606\n```\n\n##### TransferQueue\n\n> 拥有transfer方法，传输，当transfer一个元素时，如果有take方法阻塞等待获取元素，则不向队列中保存，直接给等待的take方法\n>\n> 使用情景：如果将元素放入队列，再拿给消费者线程，太慢了，如果需要的效率更高，可以使用TransferQueue来解决更高的并发\n\ntransfer(): \n\n```java\npackage c_025;\npublic class T08_TransferQueue {\n    public static void main(String[] args) {       \n        TransferQueue mq = new LinkedTransferQueue();       \n        // 先让消费者线程等待\n        new Thread(() -> {\n            try {\n                System.out.println(mq.take());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        // 再让生产者线程生产\n        try {\n            mq.transfer(\"aaa\");  // put add 都不会阻塞，会添加到容器中，只有transfer才有此种功能（等待消费者直接获取），所以transfer是有容量的\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        /*new Thread(() -> {\n            try {\n                System.out.println(mq.take());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();*/\n    }\n\n}\n\n```\n\n##### SynchronousQueue\n\n> 容量为0的队列，一种特殊的TransferQueue\n\n无法使用add() /put() 方法向容器中添加元素\n\n```java\npackage c_025;\n\npublic class T09_SynchronousQueue {\n\n    public static void main(String[] args) throws InterruptedException {\n        \n        BlockingQueue queue = new SynchronousQueue();\n        \n        new Thread(() -> {\n            try {\n                System.out.println(queue.take()); // 取不到就阻塞\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        //queue.add(\"aaa\"); // IllegalStateException: Queue full  抛出异常，因为没有容量\n        queue.put(\"aaa\");  // 会阻塞等待消费者线程获取,内部是transfer\n        \n        System.out.println(queue.size()); // 长度为0 \n    }\n}\n```\n\n\n\n### CopyOnWriteList(写时复制容器)\n\n> 当发生写操作(添加、删除、修改)时，容器就会复制原有容器一份然后对新操作进行写操作，然后再将引用转向新的容器\n\n```java\npackage c_025;\npublic class T02_CopyOnWriteList {\n    public static void main(String[] args) {\n        List<String> list =\n                //new ArrayList<>(); //会出现并发问题\n                //new Vector<>(); \n                new CopyOnWriteArrayList<>();  // 写速极慢，读取快\n\n        Random r = new Random();\n        Thread[] ths = new Thread[100];\n\n        for (int i = 0; i < ths.length; i++) {\n            Runnable task = () -> {\n                for (int j = 0; j < 1000; j++) {\n                    list.add(\"a\" + r.nextInt(100));\n                }\n            };\n            ths[i] = new Thread(task);\n\n        }\n        runAndComputeTime(ths);\n        System.out.println(list.size());\n        \n    }\n\n    static void runAndComputeTime(Thread[] ths) {\n        long start = System.currentTimeMillis();\n        Arrays.asList(ths).forEach(Thread::start);\n        Arrays.asList(ths).forEach(t -> {\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        long end = System.currentTimeMillis();\n        System.out.println(end - start);\n    }\n    \n}\n```\n\n好处：保证读操作不需要锁也能正常访问，是一种读写分离的实现方式\n\n缺点：写的效率极低，特定场景下才会使用到\n\n\n\n## 总结\n\n### 对于map/set的选择使用\n\n1. 不需要使用多线程的情况下\n\n   HashMap\n\n   TreeMap\n\n   LinkedHashMap\n\n2. 并发量比较小的情况下\n\n   Hashtable\n\n   Collections.sychronizedXXX()\n\n3. 高并发情况下：\n\n   ConcurrentHashMap\n\n   同时要求排序\n\n   ConcurrentSkipListMap\n\n\n\n### 对于队列的选择使用\n\n1. 不需要同步的队列\n\n   ArrayList\n\n   LinkedList\n\n2. 需要同步的队列,且并发量比较低\n\n   Collections.synchronizedXXX()\n\n   Vector\n\n3. 需要同步的队列，且并发量比较高\n\n   ConcurrentLinkedQueue\n\n   阻塞式队列\n\n   LinkedBlockingQueue(无界队列)\n\n   ArrayBlockingQueue(有界队列)\n\n   TransferQueue(直接将内容交给消费者执行)\n\n   SynchronusQueue(特殊的TransferQueue，容量为0)\n\n4. 执行定时任务队列\n\n   DelayQueue\n\n5. 写的时候非常少，读的时候非常多\n\n   CopyOnWriteList\n\n\n\n## 相关资料\n\n[源码来源](https://github.com/xf616510229/java-concurrent)\n\n[学习视频](https://www.bilibili.com/video/av33688545/?p=19)","tags":["多线程","并发容器"],"categories":["concurrent"]},{"title":"多线程高并发编程 - 同步器(一)","url":"/2019/08/10/高并发编程学习-多线程基础复习/","content":"\n> 本篇主要总结同步器的相关例子：包括synchronized、volatile、原子变量类（AtomicXxx）、CountDownLatch、ReentrantLock和ThreadLocal。还涉及到wait和notify/notifyAll。\n\n<!-- more -->\n\n## synchronized 关键字\n\n> 对某个对象进行加锁，保证操作原子性\n\n运行下面的代码，查看添加 `synchronized`前后的区别\n\n```java\npublic class T implements Runnable{\n\n    private int count = 10;\n    \n    @Override\n    public /*synchronized*/ void run() {\n        count--;\n        System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n    }\n\n    public static void main(String[] args) {\n        T t = new T();\n        for (int i = 0; i < 5; i++) {\n            new Thread(t).start();\n        }\n    }\n}\n```\n\n不添加`synchronized`某次运行结果：\n\n```java\nThread-0 count = 7\nThread-4 count = 5\nThread-3 count = 6\nThread-2 count = 7\nThread-1 count = 7\n```\n\n出现上面这种结果原因：\n线程重入的问题（线程执行过程中，被其他线程打断），因为 count-- + sout(count) 不是原子操作\n\n解决：\n加上 synchronized 关键字，保证操作原子性\n运行结果：\n\n```java\nThread-0 count = 9\nThread-2 count = 8\nThread-4 count = 7\nThread-3 count = 6\nThread-1 count = 5\n```\n\n\n\n### 使用场景\n\n在java代码中使用`synchronized`可是使用在代码块和方法中，根据`Synchronized`用的位置可以有这些使用场景：\n\n{% asset_img bingfa-01.png %}\n\n具体查看[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_001 - c_005部分 \n\n\n\n### 知识点\n\n1. `synchronized` 锁定的不是代码块，而是 this 对象；\n2. 锁信息记录在堆内存对象中的，不是在栈引用中；\n3. `synchronized` 是互斥锁\n4. 关键字写在方法非静态上，锁的对象是当前对象`this`；\n\n```java\npublic synchronized void m() { // 等同于 synchronized (this) { \n        count--;\n        System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n}\n\n等同于\n\npublic void m() {\n    synchronized (this) { // 任何线程要执行下面的代码，必须先拿到this锁\n        // synchronized 锁定的不是代码块，而是 this 对象\n        // 如果当前对象已经被锁定，其他线程再进入时，就会进行阻塞等待\n        // 所以 synchronized 是互斥锁\n        count--;\n        System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n    }\n    // 当代码块执行完毕后，锁就会被释放，然后被其他线程获取\n}\n```\n\n5. 同步方法（加锁）和非同步方法（不加锁）是否可以同时调用？\n\n   答：肯定可以\n\n```java\npackage c_007;\n\npublic class T {\n    \n    //同步方法\n    public synchronized void m1() {\n        System.out.println(Thread.currentThread().getName() + \" m1 start\");\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" m1 end\");\n    }\n    \n    //非同步方法\n    public void m2() {\n        System.out.println(Thread.currentThread().getName() + \" m2 start\");\n        try {\n            TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" m2 end\");\n    }\n\n    public static void main(String[] args) {\n        T t = new T();\n        new Thread(t::m1).start(); //jdk8 Lambda表达式\n        new Thread(t::m2).start();\n    }\n}\n\n/**\n运行结果：\nThread-0 m1 start\nThread-1 m2 start\nThread-1 m2 end\nThread-0 m1 end\n*/\n```\n\n[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_007部分 \n\n6. 脏读现象\n   对业务写方法加锁，而对业务读方法不加锁，容易出现脏读问题，所以**视业务情况如果允许**可以给读写都加锁\n\n   [示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_008部分 \n\n7. synchronized 是可重入锁\n   即一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请时仍然会得到该对象的锁,同样的，子类调用父类的同步方法，也是可冲入的。\n\n```java\npublic class T {\n\n    synchronized void m1() {\n        System.out.println(\"m1 start \");\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //调用同样被锁的m2方法\n        m2();\n    }\n\n    synchronized void m2() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\" m2\"); // 这句话会打印，调用m2时，不会发生死锁\n    }\n    \n    public static void main(String[] args) {\n        T t = new T();\n        new Thread(()->t.m1()).start();\n    }\n}\n```\n\n​\t[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_009-C_010部分 \n\n8. `synchronized` 代码块中，如果发生异常，锁会被释放\n\n在并发处理过程中，有异常要多加小心，不然可能发生数据不一致的情况。 比如，在一个web app处理过程中，多个servlet线程共同访问同一资源，这时如果异常处理不合适，第一个线程抛出异常，其他线程就会进入同步代码区，有可能访问到异常产生的数据。因此要非常小心处理同步业务员逻辑中的异常。\n\n```JAVA\npackage c_011;\n\npublic class T {\n\n    int count = 0;\n    \n    synchronized void m() {\n        System.out.println(Thread.currentThread().getName() + \" start\");\n        while (true) {\n            count++;\n            System.out.println(Thread.currentThread().getName() + \" count=\" + count);\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (count == 5) {  // 当count == 5 时，synchronized代码块会抛出异常\n                int i = 1 / 0; \n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        T t = new T();\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                t.m();\n            }\n        };\n        new Thread(r, \"t1\").start(); // 执行到第5秒时，抛出 ArithmeticException \n        // 如果抛出异常后，t2 会继续执行，就代表t2拿到了锁，即t1在抛出异常后释放了锁\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        new Thread(r, \"t2\").start();\n    }\n\n}\n```\n\n​\t[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_011部分 \n\n### synchronized 优化\n\n1. 同步代码块中的语句越少越好\n\n```java\npackage c_016;\n\npublic class T {\n\n    int count = 0;\n    \n    synchronized void m1() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // 业务逻辑中，只有下面这句代码需要 sync， 这时不应该给整个方法上锁\n        count++;\n\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    void m2() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 业务逻辑中，只有下面这句需要 sync，这时不应该给整个方法上锁\n        // 采用细粒度的锁，可以使线程争用时间变短，从而提高效率\n        synchronized (this) {\n            count++;\n        }\n\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_016部分 \n\n2. 锁对象通常要设置为 final类型，保证引用不可以变。\n\n**锁定某个对象o，如果o属性发生变化，不影响锁的使用，但是如果o编程另一个对象，则锁定的对象发生变化。**\n\n```java\npackage c_017;\n\npublic class T {\n\n    /*final*/ Object o = new Object();//锁对象\n    \n    void m() {\n        synchronized (o) {\n            while (true) {\n                System.out.println(Thread.currentThread().getName());\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        T t = new T();\n        new Thread(t::m, \"线程1\").start(); //启用线程1\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        Thread thread2 = new Thread(t::m, \"线程2\");//启用线程2\n        t.o = new Object(); // 改变锁引用, 线程2也有机会运行，否则一直都是线程1 运行      \n        thread2.start();\n    }\n\n}\n\n```\n\n[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_017部分 \n\n3. 不建议使用字符串常量作为锁定对象\n\n> 在下面的例子中， m1和m2其实是锁定的同一对象\n> 这种情况下，还会可能与其他类库发生死锁，比如某类库中也锁定了字符串 \"Hello\"\n> 但是无法确认源码的具体位置，所以两个 \"Hello\" 将会造成死锁\n> 因为你的程序和你用的类库无意间使用了同意把锁\n\n```java\npackage c_018;\n\npublic class T {\n\n    String s1 = \"Hello\";\n    String s2 = \"Hello\";\n    \n    void m1() {\n        synchronized (s1) {\n            \n        }\n    }\n\n    void m2() {\n        synchronized (s2) {\n            \n        }\n    }\n}\n\n\n```\n\n\n\n## volatile 关键字\n\n> 关键字，使一个变量在多个线程间可见\n\n```java\n * cn: 透明的，临时的\n * \n * JMM(Java Memory Model)： \n * 在JMM中，所有对象以及信息都存放在主内存中（包含堆、栈）\n * 而每个线程都有自己的独立空间，存储了需要用到的变量的副本，\n * 线程对共享变量的操作，都会在自己的工作内存中进行，然后同步给主内存\n * \n\n```\n\n运行下面代码，对比有无volatile的情况下，整个程序运行结果的区别\n\n> 下面的代码中，**running** 是位于堆内存中的 **t** 对象的\n>\n> 当线程**t1**开始运行的时候，会把**running**值从内存中读到**t1**线程的工作区，在运行过程中直接使用这个copy，并不会每次都会去读取堆内存，\n>\n> 这样，当主线程修改**running**的值之后，**t1**线程感知不到，所以不会停止运行\n>\n> 使用`volatile`，将会强制所有线程都去堆内存中读取**running**的值\n\n```java\npackage c_012;\n\npublic class T {\n\n    /*volatile*/ boolean running = true;   \n\n    void m() {\n        System.out.println(\" m start \");\n        while (running) { // 直到主线程将running设置为false，T线程才会退出\n            // 在while中加入一些语句，可见性问题可能就会消失，这是因为加入语句后，CPU可能就会出现空闲，然后就会同步主内存中的内容到工作内存\n            // 所以，可见性问题可能会消失\n            /*try {\n                TimeUnit.MILLISECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }*/\n        }\n        System.out.println(\" m end \");\n    }\n\n    public static void main(String[] args) {\n        T t = new T();\n        new Thread(t::m, \"t1\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        t.running = true;\n    }\n\n}\n\n```\n\n​\t[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_012部分 \n\n### 知识点\n\n1. `volatile`只能保证可见性，不能保证原子性\n\n   `volatile`并不能保证多个线程共同修改running变量所带来的不一致的问题，也就是说`volatile`不能替代`synchronized`,`AtomicXXX`类也是可以保持原子性操作的，详细下面会讲到。\n\n```java\npackage c_013;\n\npublic class T {\n\n    volatile int count = 0;\n    /*AtomicInteger count = new AtomicInteger(0);*/\n    \n    /*synchronized*/ void m() {\n        for (int i = 0; i < 10000; i++) {\n            count++;\n            /*count.incrementAndGet();*/\n        }\n    }\n\n    public static void main(String[] args) {\n        // 创建一个10个线程的list，执行任务皆是 m方法\n        T t = new T();\n        List<Thread> threads = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            threads.add(new Thread(t::m, \"t-\" + i));\n        }\n        \n        // 启动这10个线程\n        threads.forEach(Thread::start);\n        \n        // join 到主线程，防止主线程先行结束\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // 10个线程，每个线程执行10000次，结果应为 100000\n        System.out.println(t.count);  // 所得结果并不为 100000，说明volatile 不保证原子性\n    }\n\n}\n\n```\n\n### volatile与synchronize的区别\n\n|             | 保持可见性 | 保持原子性 | 效率 |\n| ----------- | ---------- | ---------- | ---- |\n| synchronize | √          | √          | 低   |\n| valatile    | √          | ×          | 高   |\n\n\n\n## AtomicXXX 类\n\n`AtomicXXX `代表此类中的所有方法都是原子操作，并且可以保证可见性\n\nAtomicInteger举例：\n\n```java\npackage c_013;\n\npublic class T {\n\n    AtomicInteger count = new AtomicInteger(0);\n    \n    void m() {\n        for (int i = 0; i < 10000; i++) \n            count.incrementAndGet();\n        }\n    }\n\n    public static void main(String[] args) {\n        // 创建一个10个线程的list，执行任务皆是 m方法\n        T t = new T();\n        List<Thread> threads = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            threads.add(new Thread(t::m, \"t-\" + i));\n        }\n        \n        // 启动这10个线程\n        threads.forEach(Thread::start);\n        \n        // join 到主线程，防止主线程先行结束\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // 10个线程，每个线程执行10000次，结果应为 100000\n        System.out.println(t.count);  \n    }\n\n}\n\n/**\n* 运行结果： 100000\n*/\n\n```\n\n\n\n## CountDownLatch\n\n##### 介绍\n\nCountDownLatch是一个计数（构造函数中指定此数值）的锁，当通过countDown方法将此计数值减为0时会唤醒之前调用await的线程。一般用于当某些任务执行完后，在执行其他任务的场景中。\n\n\n\n##### 实现原理\n\n计数器通过使用锁（共享锁、排它锁）实现,\n\nCountDownLatch是通过一个计数器来实现的，计数器的初始值为等待线程数量。\n\n> CountDownLatch是一个同步的辅助类，它能够使一个线程等待其他线程完成各自的工作后再执行。\n>\n> CountDownLatch是基于AbstractQueuedSynchronizer（AQS）实现的，其通过state作为计数器。构造CountDownLatch时初始化一个state，以后每调用countDown方法一次，state减1；当state=0时，唤醒在await上被挂起的线程。\n>\n> CountDownLatch的计数器state不能被重置，如果需要一种能重置count的版本，可以考虑使用CyclicBarrier。\n\n具体代码使用可以参考题目测试中的<a href=\"#CountDownLatch11\">代码实现</a>\n\n\n\n## ReentrantLock\n\n> ReentrantLock可以用于替代synchronized\n>\n> ReentrantLock使用完毕后，必须调用unlock()手动释放锁\n\n代码示例：\n\n```java\npublic class ReentrantLock1 {\n    \n    ReentrantLock lock = new ReentrantLock();\n    \n    /*synchronized*/ void m1() {\n        /*for (int i = 0; i < 10; i++) {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(i);\n        }*/\n        lock.lock(); // 相当于 synchronized\n        try {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(i);\n            }\n        } finally {\n            lock.unlock(); // 使用完毕后，必须手动释放锁\n            // 不同于synchronized，抛出异常后，不会自动释放锁，需要我们在finally中释放此锁\n        }\n    }\n    \n    /*synchronized*/ void m2() {\n        /*System.out.println(\"m2...\");*/\n        \n        lock.lock(); // 相当于 synchronized\n        try {\n            System.out.println(\"m2...\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ReentrantLock1 r1 = new ReentrantLock1();\n        new Thread(r1::m1, \"t1\").start(); // m1 已经执行，被t1占有锁this\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        new Thread(r1::m2, \"t2\").start(); // 锁已经被其他线程占用，m1执行完毕后，不会执行\n    }\n\n}\n\n\n```\n\n\n\n### ReentrantLock 和 synchronized 的区别\n\n> ReentrantLock 可以完成 synchronized 的任何功能,并且ReentrantLock比 synchronized 更灵活\n\n1. ReentrantLock 可以进行尝试锁定\n\n   使用 tryLock() 如果无法锁定、或者在指定时间内无法锁定，线程可以决定是否继续等待。\n\n```java\npackage c_020;\n\npublic class ReentrantLock3 {\n    ReentrantLock lock = new ReentrantLock();\n    void m1() {\n        lock.lock(); // 相当于 synchronized\n        try {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(i);\n            }\n        } finally {\n            lock.unlock(); // 使用完毕后，必须手动释放锁\n            // 不同于synchronized，抛出异常后，不会自动释放锁，需要我们在finally中释放此锁\n        }\n    }\n    void m2() {\n        //沉睡13秒看拿到锁情况\n        /*try {\n            TimeUnit.SECONDS.sleep(13);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }*/\n        // 尝试获取锁，返回true拿到了\n        if (lock.tryLock()) {\n            // lock.tryLock(5, TimeUnit.SECONDS) // 等5s内还没拿到就返回false\n            try {\n                System.out.println(\"m2...\");\n            }finally {\n                System.out.println(\"t2释放锁...\");\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\" m2 没拿到锁\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        ReentrantLock3 r1 = new ReentrantLock3();\n        new Thread(r1::m1, \"t1\").start(); // m1 已经执行，被t1占有锁this\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        new Thread(r1::m2, \"t2\").start(); // 锁已经被其他线程占用，m1执行完毕后，不会执行\n    }\n}\n\n```\n\n结果：\n\n```java\n0\nm2 没拿到锁\n1\n...\n10\n\n```\n\n\n\n2. ReentrantLock 可以调用 lockInterruptibly方法，可以对线程interrupt方法做出响应，中断线程等待\n\n```java\npackage c_020;\n\npublic class ReentrantLock4 {\n\n    public static void main(String[] args) {\n        ReentrantLock lock = new ReentrantLock();\n        new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"t1 start\");\n                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);  // 线程一直占用锁\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n            \n        }, \"t1\").start();\n\n        Thread t2 = new Thread(() -> {\n\n            try {\n                lock.lockInterruptibly(); // t2 尝试获取锁\n                System.out.println(\"t2 start\");\n            } catch (InterruptedException e) {\n                System.out.println(\"t2 等待中被打断\");\n            } finally {\n                lock.unlock(); // 没有锁定进行unlock就会抛出 IllegalMonitorStateException \n            }\n        }, \"t2\");\n        t2.start();\n\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 打断线程2的等待\n        t2.interrupt();\n        \n    }\n\n}\n\n```\n\n3. ReentrantLock 可以指定为公平锁，synchronized 是不公平锁\n\n> 公平锁: 先获取锁的人，在锁被释放时，优先获得锁\n>\n> 不公平锁，无论先后，线程调度器将会随机给某个线程锁，不用计算线程时序，效率较高\n\n```java\npackage c_020;\npublic class ReentrantLock5 extends Thread {\n\n    private static ReentrantLock lock = new ReentrantLock(true);// 指定锁为公平锁\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName() + \"获取锁\");\n            } finally {\n                lock.unlock(); // 公平锁 t1 unlock 后，等待时间长的一定是 t2 所以下次一定是 t2 执行\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ReentrantLock5 t1 = new ReentrantLock5();\n        ReentrantLock5 t2 = new ReentrantLock5();\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n运行结果：\n\n```java\nThread-0获取锁\nThread-1获取锁\nThread-0获取锁\nThread-1获取锁\nThread-0获取锁\nThread-1获取锁\n。。。。\n\n```\n\n\n\n[示例代码](https://github.com/ShawnJim/java-concurrent/tree/master/mashibing/src) c_020部分 \n\n\n\n## ThreadLocal\n\n> 线程局部变量\n\n### 特点：\n\nThreadLocal：使用空间换时间  效率更高\n线程同步：使用时间换空间\n\n\n\n> ThreadLocal可能会导致内存泄漏\n\n使用示例：\n\n```java\npackage c_022;\n\npublic class ThreadLocal2 {\n\n    static ThreadLocal<Person> p = new ThreadLocal<>();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(p.get()); // 2. 虽然threadLocal时共享变量，但是取不到其他线程放入的值，所以此处为null\n        }).start();\n\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            p.set(new Person()); // 1. 往线程局部变量放入一个person\n        }).start();\n    }\n    \n    static class Person {\n        String name = \"zhangsan\";\n    }\n}\n\n```\n\n\n\n\n\n## 题目测试1\n\n### 题目\n\n> 实现一个容器，提供两个方法，add，size\n> 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束\n\n\n\n### 容器实现\n\n容器实现很简单，我们就使用一个集合就搞定了，然后提供add，size方法，容器类如下：\n\n```java\npackage c_019_m;\n\npublic class MyContainer {\n\n    private List<Object> list = new ArrayList<>();\n\n    public void add(Object ele) {\n        list.add(ele);\n    }\n\n    public int size() {\n        return list.size();\n    }\n\n}\n\n\n```\n\n\n\n### 线程实现\n\n线程的方案就很多了\n\n#### volatile 关键字\n\n使用`volatile` 关键字使容器保持可见性，使list发生变化时，主动通知其他线程，更新工作空间\n\n```java\npackage c_019_m;\n\npublic class MyContainer {\n\n    //容器添加volatile关键字保持可见性\n    private volatile List<Object> list = new ArrayList<>();\n    \n    //后续省略。。。。\n}\n\n\npublic static void main(String[] args) {\n        MyContainer container = new MyContainer();\n\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                container.add(new Object());\n                System.out.println(\"add \" + i);\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                \n            }\n        }, \"t1\").start();\n\n        new Thread(() -> {\n            while (true) {\n                if (container.size() == 5) {\n                    break;\n                }\n            }\n            System.out.println(\"监测到容器长度为5，线程2立即退出\");\n        }, \"t2\").start();\n\n}\n\n```\n\n结果：\n\n```java\nadd 0\nadd 1\nadd 2\nadd 3\nadd 4\n监测到容器长度为5，线程2立即退出\n\n```\n\n这个方案虽说可以实现，但也是有一些问题存在的：\n\n1. 不够精确，当container.size == 5 还未执行break时，有可能被其他线程抢占；\n2. 损耗性能，t2 线程，一直在走while循环，很浪费性能\n\n#### wait() 与 notify()\n\n> wait() 与 notify() 方法的调用必须在同步代码块中\n>\n> wait(): 会释放当前的锁，然后让出CPU，进入等待状态。\n>\n> notify/notifyAll() : 会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。\n\n思路： 由于wait() 会释放锁，所以我们可以先启动监控线程t2，调用wait()释放锁，再起线程 t1，当满足条件时notify()唤醒线程t1.\n\n代码实现：\n\n```java\npublic static void main(String[] args) {\n\n        MyContainer3 container = new MyContainer3();\n\n        final Object lock = new Object();\n\n        new Thread(() -> {\n            synchronized (lock) {\n                System.out.println(\"t2 启动\");\n                if (container.size() != 5) {\n                    try {\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.println(\"监测到容器长度为5，线程2立即退出\");\n                lock.notify();\n            }\n        }, \"t2\").start();\n\n        // 先启动t2线程，让t2线程进入等待状态\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        new Thread(() -> {\n            synchronized (lock) {\n                for (int i = 0; i < 10; i++) {\n                    container.add(new Object());\n                    System.out.println(\"add \" + i);\n                    // 当长度为5时，通知 t2 进行退出\n                    if (container.size() == 5) {\n                        lock.notify(); // notify 不会释放锁，即便通知t2，t2也获取不到锁\n                        // 可以在wait一下，将锁释放，再让t2通知t1继续执行\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    try {\n                        TimeUnit.SECONDS.sleep(1);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }, \"t1\").start();\n}\n\n```\n\n问题解决，但是呢，这样看起来代码是不是有点小复杂，有点绕了。。。so，继续。\n\n\n\n#### <a name=\"CountDownLatch11\">CountDownLatch</a>\n\n使用Latch (门闩) 替代 wait notify来进行通信好处是，通信简单，同时也可以指定等待时间\n\n使用await和countDown 方法替代 wait 和 notify\n\nCountDownLatch不涉及锁定，当count值为0时，当前线程继续运行；\n\n当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了\n\n```java\npublic static void main(String[] args) {\n\n        MyContainer5 container = new MyContainer5();\n\n        // Count down 往下数  Latch 门闩\n        // 门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性\n        // 门闩的等待，不会持有任何锁\n        CountDownLatch latch = new CountDownLatch(1);//创建门闩\n\n        new Thread(() -> {\n            System.out.println(\"t2 启动\");\n            if (container.size() != 5) {\n                try {\n                    latch.await();\n                    // 指定等待时间\n                    //latch.await(5000, TimeUnit.MILLISECONDS);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"监测到容器长度为5，线程2立即退出\");\n        }, \"t2\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            System.out.println(\"t1 启动\");\n            for (int i = 0; i < 10; i++) {\n                container.add(new Object());\n                System.out.println(\"add \" + i);\n                // 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会执行\n                if (container.size() == 5) {\n                    latch.countDown();\n                }\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"t1\").start();\n}\n\n```\n\n\n\n## 题目测试2\n\n### 题目\n\n> 写一个固定容量的容器，拥有put和get方法，以及getCount方法* 能够支持2个生产者线程以及10个消费者线程的阻塞调用\n\n\n\n### 容器实现\n\n注意点：生产者消费者模式\n\n> 如果调用 get方法时，容器为空，get方法就需要阻塞等待\n>\n> 如果调用 put方法时，容器满了，put方法就需要阻塞等待\n\n#### wait/notify\n\n```java\npackage c_021_m;\n\npublic class MyContainer1<T> {\n    \n    private final LinkedList<T> list = new LinkedList<>();\n    private final int MAX = 10;\n    private int count = 0;\n\n    public synchronized void put(T t) {\n        while (MAX == count) { // 如果容量最大，释放锁等待    ///思考？ 【这里为什么使用while，而不是使用if？？？】\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 否则 put \n        list.add(t);\n        ++count;\n        this.notifyAll(); // 通知消费者线程，可以消费了\n        //思考？ 【这里为什么调用 notifyAll 而不是 notify ？】\n    }\n\n    public synchronized T get() {\n        while (list.size() == 0) { // 如果容量为空，释放锁等待  \n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // 否则获取\n        T t = list.removeFirst();\n        count--;\n        this.notifyAll(); // 通知生产者线程生产\n        return t;\n    }\n}\n\n```\n\n思考解答：\n\n```\n为什么使用while 而不是使用 if ？？？\n在与wait()的配合中，百分之99的程序都是与while而不是if结合使用。\n上述代码中，在容器已满的情况下，put方法会wait等待，当容器中的元素被消费者消费了一部分，就会唤醒所有put方法，\nput方法会继续向下执行，直接执行list.add(t)，那么多个生产者线程执行list.add() 就有可能出现数据一致性的问题。\n如果使用while则会循环判断，就避免了这些问题。\n\n不是有锁吗？为什么会需要循环判断？\nwait之后，锁就会失去，再次被唤醒时，并且得到锁之后，是从list.add()开始执行的，会无判断直接加入到容器中。\n\n\n为什么调用 notifyAll 而不是 notify ？\n因为notify有可能再次叫醒一个生产者线程\n\n```\n\n\n\n#### 使用Lock&Condition\n\n使用Lock和Condition实现，可以精确唤醒某些线程，提高执行效率\n\n```java\npackage c_021_m;\npublic class MyContainer2<T> {\n\n    private final LinkedList<T> list = new LinkedList<>();\n    private final int MAX = 10;\n    private int count = 0;\n\n    private Lock lock = new ReentrantLock();\n    private Condition producer = lock.newCondition();\n    private Condition consumer = lock.newCondition();\n\n\n    public  void put(T t) {\n        lock.lock();\n        try {\n            while (MAX == count) {\n                producer.await();\n            }\n            list.add(t);\n            ++count;\n            consumer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public  T get() {\n        lock.lock();\n        try {\n            while (list.size() == 0) {\n                producer.signalAll();\n                consumer.await();\n            }\n            producer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n        T t = list.removeFirst();\n        count--;\n        return t;\n    }\n\n    public static void main(String[] args) {\n        MyContainer2<String> c = new MyContainer2<>();\n        // 启动消费者线程\n        for (int i = 0; i < 100; i++) {\n            new Thread(() -> {\n                try {\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                for (int j = 0; j < 5; j++) {\n                    System.out.println(\"容器内所剩值：\"+c.count+\" ; c: \"+c.list.toString());\n                    System.out.println(c.get());\n                }\n            }, \"c_\" + i ).start();\n        }\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        for (int i = 0; i < 2; i++) {\n            new Thread(()->{\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                for (int j = 0; j < 2; j++) {\n                    System.out.println(\"插入值: \"+Thread.currentThread().getName() + \" \" + j);\n                    c.put(Thread.currentThread().getName() + \" \" + j);\n                }\n            }, \"p_\" + i).start();\n        }\n    }\n}\n\n\n```\n\n结果：\n\n```java\n容器内所剩值：0 ; c: []\n插入值: p_1 0\n插入值: p_1 1\n容器内所剩值：2 ; c: [p_1 0, p_1 1]\np_1 0\n容器内所剩值：1 ; c: [p_1 1]\np_1 1\n容器内所剩值：0 ; c: []\n容器内所剩值：0 ; c: []\n...\n插入值: p_0 0\n插入值: p_0 1\np_0 0\n容器内所剩值：1 ; c: [p_0 1]\np_0 1\n容器内所剩值：0 ; c: []\n\n```\n\n\n\n\n\n## 相关资料\n\n[CountDownLatch相关资料](https://yq.aliyun.com/articles/592274)\n\n[源码来源](https://github.com/xf616510229/java-concurrent)\n\n[学习视频](https://www.bilibili.com/video/av33688545/?p=19)","tags":["多线程"],"categories":["concurrent"]},{"title":"初识SpringBoot丨第九篇：自定义Starter","url":"/2019/07/31/初识SpringBoot丨第九篇:自定义Starter/","content":"\n> 场景如下： 在日常开发中，某一天感觉自己所在项目中所需要用到的功能是自己很久以前就开发过得，例如权限控制（打个比方啦）。这时候，我们还可以找到以前老项目,为了以后的重用性，我们就可以将该模块功能抽成一个通用的Starter。\n\n<!-- more -->\n\n\n\n## 创建自定义Starter工程\n\n如何创建，我们可以参照`mybatis`对`springboot`的适配包来实施，首先我们先看`mybatis`的适配包结构\n\n{% asset_img 1564557202745.png %}\n\n所以，我们就有了学习建包的例子，就可以往下走了\n\n下面就以创建启动器包（入口包）和自动配置包为例（绝对不是偷懒--!）\n\n\n\n### 实现功能\n\n**功能：简单的获取 application配置的用户对象信息并提功服务接口返回**\n\n\n\n### 创建启动器模快\n\n启动器模快我们使用`maven`来创建,具体创建过程我就不重复了，在创建好之后我们就在pom中引入我们的功能模块依赖就行，这个模快的作用就是整合你Starter工程所需的所有模快。\n\npom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.shawn.mystarter</groupId>\n    <artifactId>mystarter-spring-boot-starter</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <!-- 引入自动配置包 -->\n        <dependency>\n            <groupId>com.shawn.mystarter</groupId>\n            <artifactId>mystarter-spring-boot-starter-autoconfiguer</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n\n\n### 自动配置模快\n\n#### 创建工程\n\n自动配置模快的话我们用Springboot 来建立，毕竟建立简单而且快速。。\n\npom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.6.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.shawn.mystarter</groupId>\n    <artifactId>mystarter-spring-boot-starter-autoconfiguer</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>mystarter-spring-boot-starter-autoconfiguer</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n```\n\n**包结构如下**\n\n{% asset_img 1564491947246.png %}\n\n#### 自动配置类 & 功能模块\n\n类结构如下\n\n{% asset_img 1564558536160.png %}\n\n**MystarterAutoConfiguration自动配置类：**\n\n所需初始化配置项都写在这\n\n```java\npackage com.shawn.mystarter.mystarter;\n\nimport com.shawn.mystarter.mystarter.bean.User;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n//@ConditionalOnWebApplication //web应用才生效\n@EnableConfigurationProperties(MystarterProperties.class) //导入配置类MystarterProperties\npublic class MystarterAutoConfiguration implements InitializingBean {\n\n    private MystarterProperties mystarterProperties;\n\n    private BeanInitializer beanInitializer;\n\n    private User user;\n\n\n    public MystarterAutoConfiguration(MystarterProperties mystarterProperties) {\n        this.mystarterProperties = mystarterProperties;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 初始化 用户 并加载到容器 （测试需要）\n        initUser();\n    }\n\n\n    public void initUser() throws Exception{\n        //省略 配置文件空值判断 ，初始化User bean值\n       this.user = new User(this.mystarterProperties.getUserName(),this.mystarterProperties.getEmail());\n    }\n\n    /**\n    * 工程初识化将用户 加载到容器中  测试用\n    */\n    @Bean\n    @ConditionalOnMissingBean   //当容器中不存在 userBean是才写入容器\n    public User uesr(){\n        return this.user;\n    }\n}\n\n```\n\n**MystarterProperties 工程配置类：**\n\n```java\npackage com.shawn.mystarter.mystarter;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n\n//绑定applicatioin文件以mystarter为前缀的值\n@ConfigurationProperties(prefix = MystarterProperties.MYSTARTER_PREFIX)\npublic class MystarterProperties {\n    public static final String MYSTARTER_PREFIX = \"mystarter\";\n\n    private String userName;\n    private String email;\n\n    //省略 getter setter\n}\n\n```\n\n**BeanInitializer获取bean工具类** :\n\n实现功能所需\n\n```java\npackage com.shawn.mystarter.mystarter;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BeanInitializer implements ApplicationContextAware {\n\n    private static ApplicationContext applicationContext;\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContextParam) throws BeansException {\n        applicationContext=applicationContextParam;\n    }\n    public static Object getObject(String id) {\n        Object object = null;\n        object = applicationContext.getBean(id);\n        return object;\n    }\n    public static <T> T getObject(Class<T> tClass) {\n        return applicationContext.getBean(tClass);\n    }\n\n    public static Object getBean(String tClass) {\n        return applicationContext.getBean(tClass);\n    }\n\n    public static <T> T getBean(Class<T> tClass) {\n        return applicationContext.getBean(tClass);\n    }\n}\n\n```\n\n**User  :**\n\n```java\npackage com.shawn.mystarter.mystarter.bean;\n\npublic class User {\n\n    private String userName;\n    private String email;\n\n    public User(String userName, String email) {\n        this.userName = userName;\n        this.email = email;\n    }\n\n    //省略 getter setter  toString\n}\n\n```\n\n**UserService:**\n\n功能服务层接口\n\n```java\npackage com.shawn.mystarter.mystarter.service;\n\nimport com.shawn.mystarter.mystarter.BeanInitializer;\nimport com.shawn.mystarter.mystarter.bean.User;\n\npublic class UserSevice {\n\n    /**\n     * 模拟service层获取UserBean的方法\n     * @return\n     */\n    public static User getUser(){\n        return BeanInitializer.getBean(User.class);\n    }\n\n}\n\n```\n\n#### spring.factories配置\n\n在resources下创建META-INF目录，并创建spring.factories，并配置所需要初始化的配置类\n\nspring.factories.xml\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  com.shawn.mystarter.mystarter.MystarterAutoConfiguration,\\\n  com.shawn.mystarter.mystarter.BeanInitializer\n\n\n```\n\n\n\n### Maven install\n\n将已经创建好的自定义starter 打包到maven本地仓库\n\n{% asset_img 1564559495957.png %}\n\n> 注意 \n\n**打包顺序是先子包再父包**\n\n\n\n## 引用自定义Starter\n\n在其他工程pom文件中引用我们刚创建好的 工具包，然后开始测试功能\n\n{% asset_img 1564494584299.png %}\n\n### 测试\n\napplication.properties\n\n```properties\nmystarter.userName = \"username23232\"\nmystarter.email = \"2510xxxxx@qq.com\"\n\n```\n\n\n\n测试代码\n\n```java\npackage com.shawn.chapter8;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Chapter8StarterApplicationTests {\n\n    @Test\n    public void contextLoads() {\n        //服务层接口获取 容器中的User\n        User user = UserSevice.getUser();\n        System.out.println(user.toString());\n    }\n\n}\n\n```\n\n结果\n\n{% asset_img 1564559850942.png %}\n\n\n\n## 总结\n\n嗯！ 测试结束，功能实现起来有点乱，主要是想顺便整合一下之前所学SpringBoot的相关配置，，so...\n\n结果从流程看起来还是有点乱的，，多担待哈！！\n\n\n\n[个人项目地址](https://github.com/ShawnJim/spring-boot-learning)\n\n","tags":["java","Spring"],"categories":["SpringBoot"]},{"title":"centos升级内核版本","url":"/2019/07/31/centos升级内核版本/","content":"\n由于安装Docker时，Docker支持\n\n> CentOS 7 (64-bit)\n> CentOS 6.5 (64-bit) 或更高的版本\n\n<!-- more -->\n\n> Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 \nDocker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本\n\nCentOS 7 的内核一般都是3.10的，而CentOS 6.X 的内核一般都是2.6，在2.6的内核下，Docker运行会比较卡，所以一般会选择升级到3.10版本以上。\n\n升级内核的方式，网上有很多方法是下载内核然后编译，这样需要安装很多必备的环境和工具，比较麻烦，但是也有助于我们了解内核的编译\n\n## 升级步骤\n\n编译内核方式升级： \n[参考文档](https://segmentfault.com/a/1190000000733628#articleHeader13)\n\n### 查看当前内核版本\n\n```\nCentOS release 6.5 (Final)\nKernel \\r on an \\m\n[root@localhost ~]# uname -a\nLinux localhost.localdomain 2.6.32-431.el6.x86_64 #1 SMP Fri Nov 22 03:15:09 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n### 导入public key\n\n```\n[root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n```\n\n### 安装ELRepo到CentOS\n\n 选择要安装的ELRepo \n\n```\n[root@localhost ~]# rpm -Uvh yum install https://www.elrepo.org/elrepo-release-6-9.el6.elrepo.noarch.rpm\n```\n\n> 注意\n\n如果地址404可以去http://elrepo.org/tiki/tiki-index.php重新选择地址下载\n\n{% asset_img 1564309413081.png %}\n\n### 安装 kernel-lt（lt=long-term）\n\n```\n[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-lt -y\n\n或者 安装kernel-ml（ml=mainline）\n\n[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-ml -y\n```\n\n### 编辑grub.conf文件，修改Grub引导顺序\n\n```\n [root@localhost ~]# vim /etc/grub.conf\n```\n\n因为一般新安装的内核在第一个位置，所以设置default=0，表示启动新内核\n\n{% asset_img 1564309747443.png %}\n\n### 重启\n\n查看此时内核版本：\n\n```\n#重启\n[root@localhost ~]# reboot \n[root@localhost ~]# uname -r\n4.4.186-1.el6.elrepo.x86_64\n```\n\n成功！\n\n","tags":["shell","centos"],"categories":["liunx"]},{"title":"Docker的安装与使用","url":"/2019/07/30/Docker的安装与使用/","content":"> 使用容器可以更快地构建和部署新应用程序。Docker容器将软件及其依赖关系整合到一个标准化的软件开发单元中，包括运行所需的一切：代码，运行时，系统工具和库。这可以保证您的应用程序始终运行相同，并使协作变得像共享容器映像一样简单。\n<!-- more -->\n\n\n## 安装Docker\n\n​    目前，[Docker官网](https://www.docker.com/)上提供的docker是基于`centos7`系列安装方法。如果我们想在低于3.x内核的操作系统（比如`Centos6.7`）上装Docker最新版，势必要升级内核。但是想要在`Centos6.7`上安装可以安装较低版本的Docker。事实上，对于内核版本要大于3.10这个要求，是从`Docker1.8.2`版本开始的，`Docker`之前的版本是可以运行在较低内核版本之上的，比如`1.7.1`。\n\n### Centos 6 安装步骤\n\n#### 查看centos 内核版本（版本要求 3.10 以上）\n\n```shell\nuname -r\n```\n\n#### 升级内核版本（可选，版本低于3.10）\n\n```shell\nyum update\n//安装时间有点长~~  需要耐心等待0-0\n```\n\n#### 安装\n\n```shell\nyum install docker\n```\n\n如报错：`  No package docker available. Error: Nothing to do` 步骤如下^^!\n\n```shell\n[root@localhost ~]# sudo yum install epel-release\n# 安装docker\n[root@localhost ~]# yum install docker\n# 验证安装\n[root@localhost ~]# docker --version\ndocker - version 1.5\nCopyright 2003, Ben Jansens <ben@orodu.net>\n```\n\n#### 卸载\n\n1. 列出你安装过的包\n\n```shell\n$ yum list installed | grep docker\nyum list installed | grep docker\ndocker-engine.x86_64   1.7.1-1.el7 @/docker-engine-1.7.1-1.el7.x86_64.rpm123\n```\n\n2. 删除安装包\n\n```shell\n$ sudo yum -y remove docker-engine.x86_64\n```\n\n\n\n启动\n\n额！！ 博主再按照教程安装时遇到启动失败的问题v_v,不过十分幸运的是博主很快就百度get了解决方案，再此感谢下[Angel_Kitty](https://www.cnblogs.com/ECJTUACM-873284962/)解决方案提供者，下面贴出问题与方案\n\n#### 遇到问题\n\n```shell\n[root@localhost ~]# docker start\nSegmentation Fault or Critical Error encountered. Dumping core and aborting.\n```\n\n\n\n##### 解决方案\n\n###### 先移除docker\n\n```powershell\n[root@Sakura ~]# yum remove docker\n```\n\n###### 再移除docker-selinux(如果你之前有安装过的话)\n\n```powershell\n[root@Sakura ~]# yum remove docker-selinux\n```\n\n###### 然后修改文件\n\n```powershell\n[root@Sakura ~]# vi /etc/yum.repos.d/docker.repo\n```\n\n###### 直接填入如下内容\n\n```shell\n[dockerrepo]\n\nname=Docker Repository\n\nbaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/\n\nenabled=1\n\ngpgcheck=1\n\ngpgkey=https://yum.dockerproject.org/gpg\n```\n\n###### 然后启动安装：\n\n```shell\n[root@Sakura ~]# yum install docker-engine\n```\n\n作为依赖被安装: docker-engine-selinux.noarch 0:1.10.2-1.el7.centos\n\n然后启动docker服务：\n\n```shell\n[root@Sakura ~]# service docker start\n```\n\n返回如下状态码：\n\n```shell\nStarting cgconfig service:                                 [  OK  ]\nStarting docker:                                           [  OK  ]\n```\n\n搞定！\n\n\n\n#### 设置自启动（centos 6.x环境）\n\n##### 编辑 /etc/rc.d/rc.local 文件\n\n```shell\n[root@localhost ~]# vim /etc/rc.d/rc.local  \n```\n\n写入下面内容\n\n```shell\n#!/bin/sh\n#\n# This script will be executed *after* all the other init scripts.\n# You can put your own initialization stuff in here if you don't\n# want to do the full Sys V style init stuff.\n\ntouch /var/lock/subsys/local\n/etc/init.d/docker start\n```\n\n\n\n### Centos7 安装步骤\n\ncentos 7 安装docker 相比6 来说 那可是相当简单了\n\n**详细如下：**\n\n```shell\n# step 1: 安装必要的一些系统工具\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n# Step 2: 添加软件源信息\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n# Step 3: 更新并安装 Docker-CE\nsudo yum makecache fast\nsudo yum -y install docker-ce\n# Step 4: 开启Docker服务\nsudo service docker start\n\n注意：其他注意事项在下面的注释中\n# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。\n# vim /etc/yum.repos.d/docker-ce.repo\n#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1\n#\n# 安装指定版本的Docker-CE:\n# Step 1: 查找Docker-CE的版本:\n# yum list docker-ce.x86_64 --showduplicates | sort -r\n#   Loading mirror speeds from cached hostfile\n#   Loaded plugins: branch, fastestmirror, langpacks\n#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable\n#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable\n#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable\n#   Available Packages\n# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)\n# sudo yum -y install docker-ce-[VERSION]\n# 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。\n# yum list docker-ce-selinux- --showduplicates | sort -r\n# sudo yum -y install docker-ce-selinux-[VERSION]\n\n# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令\n# 经典网络：\n# sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo\n# VPC网络：\n# sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n#### 安装校验\n\n```shell\nroot@iZbp12adskpuoxodbkqzjfZ:$ docker version\nClient:\n Version:      17.03.0-ce\n API version:  1.26\n Go version:   go1.7.5\n Git commit:   3a232c8\n Built:        Tue Feb 28 07:52:04 2017\n OS/Arch:      linux/amd64\n\nServer:\n Version:      17.03.0-ce\n API version:  1.26 (minimum version 1.12)\n Go version:   go1.7.5\n Git commit:   3a232c8\n Built:        Tue Feb 28 07:52:04 2017\n OS/Arch:      linux/amd64\n Experimental: false\n```\n\n[文档地址](https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.3c4e1991uA8VE4)\n\n\n\n## Docker 使用\n\n### 使用阿里云镜像加速\n\n由于网络原因，我们在pull Image 的时候，从Docker Hub上下载会很慢。\n\n修改文件\n\n```\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://a3zqcvhc.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n# https://a3zqcvhc.mirror.aliyuncs.com 由自己去阿里云官网注册获取\nhttps://cr.console.aliyun.com/cn-beijing/instances/mirrors\n```\n\n\n\n**或者使用daocloud仓库**\n\n [仓库地址](https://www.daocloud.io/mirror#accelerator-doc)\n\n\n\n### 镜像操作\n\n| 操作 | 命令                                            | 说明                                                     |\n| ---- | ----------------------------------------------- | -------------------------------------------------------- |\n| 检索 | docker  search 关键字  eg：docker  search redis | 我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。 |\n| 拉取 | docker pull 镜像名:tag                          | :tag是可选的，tag表示标签，多为软件的版本，默认是latest  |\n| 列表 | docker images                                   | 查看所有本地镜像                                         |\n| 删除 | docker rmi image-id                             | 删除指定的本地镜像                                       |\n\nhttps://hub.docker.com/\n\n\n\n### 容器操作\n\n```shell\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps  \n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name/container-id\n\n#如果无法还是无法访问到tomcat 可以试试curl 127.0.0.1:port\n```\n\n更多命令参看\n[各镜像文档](https://docs.docker.com/engine/reference/commandline/docker/)\n\n\n\n### 安装MySQL示例\n\n```shell\ndocker pull mysql\n```\n\n\n\n#### 错误的启动\n\n```shell\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES\n42f09819908b        mysql               \"docker-entrypoint.sh\"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi\n81ec743a5271        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan\n\n\n//错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified \n  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个\n```\n\n#### 正确的启动\n\n```shell\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\nb874c56bec49        mysql               \"docker-entrypoint.sh\"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01\n```\n\n#### 做了端口映射\n\n```shell\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nad10e4bc5c6a        mysql               \"docker-entrypoint.sh\"   4 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\n```\n\n\n\n#### 几个其他的高级操作\n\n```\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\n\n---- 分割线 ----\n\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n```\n\n\n\n#### 可能出现的问题\n\n> 出现问题 ，如果mysql安装版本是8.0以上的话 用navicat连接可能会报2059 错误 ，需要注意\n\n\n\n**解决方案：**\n\n主要有2种方式。\n\n1. 自定义配置文件，并 mount 到 container里。这样在MySQL启动时，会加载我们的配置文件。 \n2. 启动MySQL容器是传入CMD，通过命令修改默认加密规则\n\n\n\n**8.0其他注意配置**\n\n进行授权远程连接(注意mysql 8.0跟之前的授权方式不同)\n\n```mysql\nmysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'WITH GRANT OPTION; \n\nmysql>FLUSH PRIVIL\n\n```\n\n更改加密规则\n\n```mysql\nALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n\n```\n\n更新root用户密码\n\n```mysql\nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password'; \n\n```\n\n刷新权限\n\n```mysql\nflush privileges;\n\n```\n\nOK，设置完成，再次使用 Navicat 连接数据库\n\n  \n## 相关资料\n\n[docker官方文档](https://docs.docker.com/)\n\n[参考博客-鸭子船长](https://www.cnblogs.com/zl1991/p/10531726.html)\n\n[阿里云相关文档](https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.3c4e1991uA8VE4)\n\n[mysql问题解决](https://blog.csdn.net/weixin_43674794/article/details/90546717)","tags":["mysql","docker","linux","tomcat","工具"],"categories":["中间件/工具"]},{"title":"初识SpringBoot丨第八篇：SpringDataJpa整合","url":"/2019/07/30/初识SpringBoot丨第八篇:SpringDataJpa整合/","content":"\n>Java Persistence API是一种标准技术，可让您将对象“映射”到关系数据库。该`spring-boot-starter-data-jpa`POM提供了上手的快捷方式。它提供以下关键依赖项：\n\n<!-- more -->\n\n- Hibernate：最受欢迎的JPA实现之一。\n- Spring Data JPA：使实现基于JPA的存储库变得容易。\n- Spring ORMs：Spring Framework的核心ORM支持。\n\n本文不会详细介绍JPA或[Spring Data](https://projects.spring.io/spring-data/)。您可以按照[“访问数据与JPA”](https://spring.io/guides/gs/accessing-data-jpa/) 从官网[spring.io](https://spring.io/)阅读[SprignDataJPA](https://projects.spring.io/spring-data-jpa/)和 [Hibernate的](https://hibernate.org/orm/documentation/)参考文档。\n\n\n\n## Spring Data JPA详细介绍\n\n常见的ORM框架中`Hibernate`的JPA最为完整，因此`Spring Data JPA` 是采用基于JPA规范的`Hibernate`框架基础下提供了`Repository`层的实现。**Spring Data Repository极大地简化了实现各种持久层的数据库访问而写的样板代码量，同时CrudRepository提供了丰富的CRUD功能去管理实体类。**\n\n> 优点\n\n- 丰富的API，简单操作无需编写额外的代码\n- 丰富的SQL日志输出\n\n> 缺点\n\n- 学习成本较大，需要学习HQL\n- 配置复杂，虽然`SpringBoot`简化的大量的配置，关系映射多表查询配置依旧不容易\n- 性能较差，对比`JdbcTemplate`、`Mybatis`等ORM框架，它的性能无异于是最差的\n\n\n\n **ORM对比图**\n\n以下针对**Spring JDBC、Spring Data Jpa、Mybatis**三款框架做了个粗略的对比。**一般应用的性能瓶颈并不是在于ORM，所以这三个框架技术选型应该考虑项目的场景、团队的技能掌握情况、开发周期(开发效率)…**\n\n| 框架对比 | Spring JDBC | Spring Data Jpa | Mybatis |\n| :------- | :---------- | :-------------- | :------ |\n| 性能     | 性能最好    | 性能最差        | 居中    |\n| 代码量   | 多          | 少              | 多      |\n| 学习成本 | 低          | 高              | 居中    |\n| 推荐指数 | ❤❤❤         | ❤❤❤❤❤           | ❤❤❤❤❤   |\n\n\n\n## 前期准备\n\n### 创建项目\n\n老规矩.. 一如既往使用`spring initialiizr`创建\n\n{% asset_img 1564288001185.png %}\n\n**pom.xml**\n\n```xml\n<!-- jpa整合包 底层使用Hibernate-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<!-- mysql 驱动 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n<!-- 测试包 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n结构图\n\n{% asset_img 1564291538028.png %}\n\n**application.yml**\n\n具体配置项可查看 `JpaProperties`（prefix=\"spring.jpa\"）配置类\n\n```yml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/chapter7_jpa?serverTimezone=UTC\n    username: root\n    password: 1234\n  jpa:\n    hibernate:\n      # 项目启动时更新或者创建数据表结构\n      ddl-auto: update\n    # 项目运行过程中 控制台打印sql\n    show-sql: true\n```\n\n\n\n## 代码操作\n\n### 配置bean\n\n编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；由于我们在全局配置文件中配置了\n\n`spring.jpa.hibernate.ddl-auto`选项，所以我们可以直接先不用再数据库中建表，直接由待会项目启动时由项目自动创建，\n\n> ddl-auto 几种属性\n\n- **create：** 每次运行程序时，都会重新创建表，故而数据会丢失\n- **create-drop：** 每次运行程序时会先创建表结构，然后待程序结束时清空表\n- **upadte：** 每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）\n- **validate：** 运行程序会校验数据与数据库的字段类型是否相同，**字段不同会报错**\n\n详细参考下方示例代码：\n\n```java\npackage com.shawn.chapter7springdatajpa.entity;\n\nimport javax.persistence.*;\n\n//使用JPA注解配置映射关系\n@Entity //告诉JPA这是一个实体类（和数据表映射的类）\n@Table(name = \"t_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；\npublic class User {\n\n    @Id //这是一个主键\n    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键\n    private Integer id;\n\n    @Column(name = \"user_name\",length = 50) //这是和数据表对应的一个列\n    private String userName;\n    \n    @Column //省略默认列名就是属性名\n    private String email;\n    \n    public User() {\n    }\n\n    public User(String userName, String email) {\n        this.userName = userName;\n        this.email = email;\n    }\n    \n    ...省略getter setter\n```\n\n### 创建dao接口继承Repository\n\n编写一个Dao接口来操作实体类对应的数据表（JpaRepository）\n\n```java\npackage com.shawn.chapter7springdatajpa.repository;\n\n//继承JpaRepository来完成对数据库的操作  接口泛型<实体类对象，主键类型>\npublic interface UserDao extends JpaRepository<User,Integer> {\n\n}\n```\n\n## 测试\n\n### 测试建表\n\n启动项目，通过配置项我们发现表已经建成功了\n\n{% asset_img 1564293387787.png %}\n\n{% asset_img 1564293447896.png %}\n\n### 测试接口\n\n接口就简单测个插入查询吧\n\n```java\npackage com.shawn.chapter7springdatajpa;\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Chapter7SpringdataJpaApplicationTests {\n\n    private static final Logger log = LoggerFactory.getLogger(Chapter7SpringdataJpaApplicationTests.class);\n\n    @Autowired\n    UserDao userDao;\n\n    @Test\n    public void contextLoads() {\n        User user = new User(\"user1\", \"2510xxxxxxxx.@xx.com\");\n        User flush = userDao.saveAndFlush(user);\n        log.info(String.format(\"插入用户数据 用户id: {%s}\",user.getId()));\n        Optional<User> userById = userDao.findById(user.getId());\n        log.info(String.format(\"查询用户 user: {%s}\",userById.toString()));\n    }\n\n```\n\n{% asset_img 1564293620556.png %}\n\n\n## 总结\n\n以上就是springdatajpa整合过程，相关资料如下\n\n[springboot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-jpa-and-spring-data)\n\n[相关个人项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter7-springdata-jpa)\n\n[参考博文](https://blog.battcn.com/2018/05/08/springboot/v2-orm-jpa/)\n\n","tags":["java","Spring","SpringDataJpa"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第七篇：Mybatis整合","url":"/2019/07/27/初识SpringBoot丨第七篇:Mybatis整合/","content":"> MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n<!-- more -->\n\n特点：\n\n- mybatis是一种持久层框架，也属于ORM映射。前身是ibatis。\n- 相比于hibernatehibernate为全自动化，配置文件书写之后不需要书写sql语句，但是欠缺灵活，很多时候需要优化；\n- mybatis为半自动化，需要自己书写sql语句，需要自己定义映射。增加了程序员的一些操作，但是带来了设计上的灵活，并且也是支持hibernate的一些特性，如延迟加载，缓存和映射等；对数据库的兼容性比hibernate差。移植性不好，但是可编写灵活和高性能的sql语句。\n\n\n\nmybatis官方呢也对SpringBoot做了一系列适配，下面我们就开始springboot对mybatis的整合吧\n\n## 前期准备\n\n### 创建项目\n\n老样子，可以用springboot提供的初识化器在建工程的时候就选择，也可以后面自己手动在pom文件中添加\n\n{% asset_img 1564219382113.png %}\n\n### 配置文件\n\npom.xml\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<!-- mybatis官方适配包 -->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.0</version>\n</dependency>\n<!-- mysql驱动 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\n**关系图**\n\n{% asset_img 1564219688583.png %}\n\napplication.yml\n\n```yaml\n#忽略数据源配置 \n。。。\n\nmybatis:\n  #配置版配置 指定mapper.xml文件地址\n  mapper-locations: classpath*:com/shawn/chapter6/mapper/*.xml\n  #mapper-locations: classpath*:mapper/*.xml  # 这种配置需要自己在resources目录下建立mapper文件夹进行存放\n  # 驼峰命名规范 如：数据库字段是  order_id 那么 实体字段就要写成 orderId\n  configuration:\n    map-underscore-to-camel-case: true\n```\n\n> 注意事项\n\n由于 **mybatis.mapper-locations=classpath:com/battcn/mapper/\\*.xml**配置的在`java package`中，而`Spring Boot`默认只打入`java package -> *.java`，所以我们需要给`pom.xml`文件添加如下内容\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n\n\n## 代码实现\n\n接下来我们就简单的用mybatis进行一个对单表的CRUD操作\n\n\n\n### 建立数据表\n\n```sql\nCREATE TABLE `t_user` (\n  `id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键自增',\n  `username` varchar(50) NOT NULL COMMENT '用户名',\n  `password` varchar(50) NOT NULL COMMENT '密码',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';\n```\n\n\n\n### 创建ORM Bean文件\n\n```java\npackage com.shawn.chapter5.entity;\n\npublic class User implements Serializable {\n    private static final long serialVersionUID = -4330472735502710660L;\n\n    private int id;\n    private String username;\n    private String password;\n\n    ... 省略getter setter\n}\n\n```\n\n\n\n> springboot对于mybatis整合有两种方式，一种是使用注解如`@select`的方式(基于mybatis3.x)，第二种则是传统配置文件的方式...\n\n### 注解版\n\n```java\npackage com.shawn.chapter6.dao;\n\nimport com.shawn.chapter6.entity.User;\nimport org.apache.ibatis.annotations.*;\n\n@Mapper\n//或者在application类中使用@MapperScan 注解进行统一管理\npublic interface UserMapper {\n\n    @Select(\"select * from t_user where id=#{id}\")\n    public User getById(Integer id);\n\n    @Delete(\"delete from t_user where id=#{id}\")\n    public int deleteById(Integer id);\n\n    @Options(useGeneratedKeys = true,keyProperty = \"id\")//主键返回\n    @Insert(\"insert into t_user(username,password) values(#{username},#{password})\")\n    public int insert(User user);\n\n    @Update(\"update t_user set username=#{username} where id=#{id}\")\n    public int update(User user);\n\n}\n```\n\n使用@MapperScan对 mapper统一管理\n\n```java\n使用MapperScan批量扫描所有的Mapper接口；\n@MapperScan(value = \"com.shawn.chapter6.mapper\")\n@SpringBootApplication\npublic class Chapter6MybatisApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Chapter6MybatisApplication.class, args);\n\t}\n}\n```\n\n\n\n### 配置版\n\n```java\npackage com.shawn.chapter6.dao;\n\nimport com.shawn.chapter6.entity.User;\nimport org.apache.ibatis.annotations.*;\n\n@Mapper\n//或者在application类中使用@MapperScan 注解进行统一管理\npublic interface UserMapper {\n    \n    public int insertOne(User user);\n}\n\n```\n\nUserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.shawn.chapter6.dao.UserMapper\"> \n<!-- namespace 指定此xml文件对应的mapper接口 -->\n\n    <!-- parameterType 指定参数传入的类型 -->    \n    <insert id=\"insertOne\" parameterType=\"com.shawn.chapter6.entity.User\">\n      INSERT INTO `t_user`(`username`,`password`) VALUES (#{username},#{password})\n    </insert>\n\n</mapper>\n```\n\n\n\n## 接口测试\n\ndao层（数据访问层）接口完成后，我们可以对写好的接口进行一系列测试\n\n```java\npackage com.shawn.chapter6;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Chapter6MybatisApplicationTests {\n\n    private static final Logger log = LoggerFactory.getLogger(Chapter6MybatisApplicationTests.class);\n\n    \n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void contextLoads() {\n        //注解版\n        User user = new User(\"user11\", \"user11\");\n        final int insertResult = userMapper.insert(user);\n        log.info(String.format(\"成功插入记录 -- 插入条数：{%s},用户id：{%s}\",insertResult,user.getId()));\n        int deleteResult = userMapper.deleteById(user.getId());\n        log.info(String.format(\"成功删除记录 -- 删除条数：{%s},删除用户：{%s}\",deleteResult,user.getId()));\n\n        //配置版\n        int insertOneResult = userMapper.insertOne(new User(\"user22\", \"user22\"));\n        log.info(String.format(\"成功插入记录 -- 插入条数：{%s}\",insertOneResult));\n    }\n\n}\n\n```\n\n**结果**\n\n{% asset_img 1564234989493.png %}\n\n\n## Mybatis-Generator\n\n此项目可以自动生成\n\nMyBatis Generator将生成：\n\n- 与表结构匹配的Java POJO\n- MyBatis / iBATIS兼容的SQL Map XML文件。MBG为配置中的每个表上的简单CRUD函数生成SQL。生成的SQL语句包括：\n  - 插入\n  - 按主键更新\n  - 通过示例更新（使用动态where子句）\n  - 按主键删除\n  - 按示例删除（使用动态where子句）\n  - 按主键选择\n  - 按示例选择（使用动态where子句）\n\n基本上的单表crud都不再需要自己来动手写了\n\n以下是相关项目地址和文档\n\n[本人项目地址](https://github.com/ShawnJim/MyBatis-Generator)\n\n[mybatis-generator快速上手文档](http://www.mybatis.org/generator/quickstart.html)\n\n\n\n## 相关资料\n\n[mybaits 官方文档](http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/)\n\n[本文相关项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter6-mybatis)\n\n","tags":["java","Spring","mybatis","mysql"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第六篇：使用jdbcTemplate访问数据库","url":"/2019/07/27/初识SpringBoot丨第六篇:使用jdbcTemplate访问数据库/","content":"> `Spring Framework`对数据库的操作在`JDBC`上面做了深层次的封装，通过`依赖注入`功能，可以将 `DataSource` 注册到`JdbcTemplate`之中，使我们可以轻易的完成对象关系映射，并有助于规避常见的错误，在`SpringBoot`中我们可以很轻松的使用它。\n\n<!-- more -->\n\n特点：\n\n- 速度快，对比其它的ORM框架而言，JDBC的方式无异于是最快的\n- 配置简单，`Spring`自家出品，几乎没有额外配置\n- 学习成本低，毕竟`JDBC`是基础知识，`JdbcTemplate`更像是一个`DBUtils`\n\n\n\n## 前期准备\n\n### 工程创建\n\n创建一个工程 选择需要用到的项目，也可以在pom文件中选择添加。\n\n{% asset_img 1564144529646.png %}\n\n### 配置文件\n\nPOM文件：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\napplication.yml\n\n```yaml\nspring:\n  datasource:\n  \t#驱动包 \n  \t#springboot2.0  默认数据源使用com.zaxxer.hikari.HikariDataSource 作为数据源，\n    #com.mysql.jdbc.Driver 已被弃用\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    \n    #数据库地址 如果出现时区错误 The server time zone value 'xxx' is unrecognize, 可在后面添加 ?serverTimezone=UTC\n    #jdbc:mysql://localhost:3306/chapter5_jdbc?serverTimezone=UTC\n    url: jdbc:mysql://localhost:3306/chapter5_jdbc\n    \n    #访问用户名\n    username: root\n    \n    #访问密码\n    password: 1234\n```\n\n\n\n效果：\n\n​\t默认是用class 作为数据源；\n\n​\t数据源的相关配置都在DataSourceProperties类中；\n\n\n\n### 配置原理\n\norg.springframework.boot.autoconfigure.jdbc：\n\n1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；\n\n2、SpringBoot默认支持的数据源；\n\nDataSourceConfiguration定义了所有支持的数据源（具体的查看 DataSourceConfiguration配置类）\n\n```java\n abstract class DataSourceConfiguration {\n     \n\t@Configuration\n    @ConditionalOnClass({BasicDataSource.class})\n    @ConditionalOnMissingBean({DataSource.class})\n    @ConditionalOnProperty(\n        name = {\"spring.datasource.type\"},\n        //该注解指定该类为数据源类\n        havingValue = \"org.apache.commons.dbcp2.BasicDataSource\",\n        matchIfMissing = true\n    )\n    static class Dbcp2 {\n        \n    }\n     \n     。。。\n }\n```\n\n3、自定义数据源类型\n\n```java\nabstract class DataSourceConfiguration {\n\t/**\n     * Generic DataSource configuration. 自定义数据源方法\n     */\n    @ConditionalOnMissingBean(DataSource.class)\n    @ConditionalOnProperty(name = \"spring.datasource.type\")\n    static class Generic {\n\n       @Bean\n       public DataSource dataSource(DataSourceProperties properties) {\n           //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性\n          return properties.initializeDataSourceBuilder().build();\n       }\n\n    }\n}\n\nproperties.initializeDataSourceBuilder().build();\n点击进入build查看实现方法\n    public T build() {\n        Class<? extends DataSource> type = this.getType();\n      \t//利用反射获取容器中的数据源\n        DataSource result = (DataSource)BeanUtils.instantiateClass(type);\n        this.maybeGetDriverClassName();\n        this.bind(result);\n        return result;\n    }\n   \n```\n\n\n\n## 项目初识化 数据库操作\n\nspringboot提供了在启动项目时执行建表sql & 数据sql的操作\n\n\n\n### 具体操作\n\napplication.yml\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/chapter5_jdbc?serverTimezone=UTC\n    username: root\n    password: 1234\n    \n    # 执行sql操作配置\n    # 账号密码\n    schema-username: root\n    schema-password: 1234\n    # 操作开关 aways为开启  never、embedded关闭\n    initialization-mode: alwas\n    # 指定文件地址 不指定则 默认为如下文件\n    # 建表文件 （schema.sql、schema-all.sql）数据语句sql文件（data.sql、data-all.sql）\n    schema:\n      - classpath*:employee.sql\n      - classpath*:schema.sql\n```\n\n{% asset_img 1564210509669.png %}\n\ndepartment.sql\n\n```sql\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for department\n-- ----------------------------\nDROP TABLE IF EXISTS `department`;\nCREATE TABLE `department` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `departmentName` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n\n启动项目查看数据库则相应表已经创建完成\n\n{% asset_img 1564210575329.png %}\n\n### 原理\n\n从源码入手，首先查看springboot这方面的自动配置类\n\n**DataSourceAutoConfiguration**\n\n```java\n@Import({DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class})\n//导入了DataSourceInitializationConfiguration 类初识化配置类\npublic class DataSourceAutoConfiguration {\n    public DataSourceAutoConfiguration() {\n        \n }\n```\n\n发现其导入了DataSourceInitializationConfiguration这个初始化配置类，再看该类\n\n**DataSourceInitializationConfiguration**\n\n```java\n@Configuration\n@Import({DataSourceInitializerInvoker.class, DataSourceInitializationConfiguration.Registrar.class})\n//导入了DataSourceInitializerInvoker执行类\nclass DataSourceInitializationConfiguration {\n    DataSourceInitializationConfiguration() {\n}\n```\n\n其导入了DataSourceInitializerInvoker这个初始化程序执行类，再继续\n\n**DataSourceInitializerInvoker**\n\n```java\nclass DataSourceInitializerInvoker implements ApplicationListener<DataSourceSchemaCreatedEvent>, InitializingBean {\n    private static final Log logger = LogFactory.getLog(DataSourceInitializerInvoker.class);\n    \n    //维护了这个数据源初始化类\n    private DataSourceInitializer dataSourceInitializer;\n    \n    private DataSourceInitializer getDataSourceInitializer() {\n        if (this.dataSourceInitializer == null) {\n            DataSource ds = (DataSource)this.dataSource.getIfUnique();\n            if (ds != null) {\n                this.dataSourceInitializer = new DataSourceInitializer(ds, this.properties, this.applicationContext);\n            }\n    }\n}\n```\n\nDataSourceInitializerInvoker实现了ApplicationListener应用程序监听接口并且内部维护了一个数据源初识化构造类 DataSourceInitializer ，到这步应该就能够发现其中实现的方法了\n\n**DataSourceInitializer** 部分代码\n\n```java\npackage org.springframework.boot.autoconfigure.jdbc;\n\nclass DataSourceInitializer {\n    private static final Log logger = LogFactory.getLog(DataSourceInitializer.class);\n    private final DataSource dataSource;\n\n    /**\n    *\t执行库sql文件方法\n    */\n    public boolean createSchema() {\n        //获取配置信息\n        List<Resource> scripts = this.getScripts(\"spring.datasource.schema\", this.properties.getSchema(), \"schema\");\n        if (!scripts.isEmpty()) {\n            //判断配置文件中开关是否为always允许\n            if (!this.isEnabled()) {\n                logger.debug(\"Initialization disabled (not running DDL scripts)\");\n                return false;\n            }\n\n            String username = this.properties.getSchemaUsername();\n            String password = this.properties.getSchemaPassword();\n            //运行\n            this.runScripts(scripts, username, password);\n        }\n\n        return !scripts.isEmpty();\n    }\n\n    /**\n    *\t执行数据文件方法 如createSchema类似\n    */\n    public void initSchema() {\n        List<Resource> scripts = this.getScripts(\"spring.datasource.data\", this.properties.getData(), \"data\");\n        if (!scripts.isEmpty()) {\n            if (!this.isEnabled()) {\n                logger.debug(\"Initialization disabled (not running data scripts)\");\n                return;\n            }\n\n            String username = this.properties.getDataUsername();\n            String password = this.properties.getDataPassword();\n            this.runScripts(scripts, username, password);\n        }\n\n    }\n\n    //开关方法\n    private boolean isEnabled() {\n        //getInitializationMode 为配置项中的 initialization-mode\n        DataSourceInitializationMode mode = this.properties.getInitializationMode();\n        if (mode == DataSourceInitializationMode.NEVER) {\n            return false;\n        } else {\n            return mode != DataSourceInitializationMode.EMBEDDED || this.isEmbedded();\n        }\n    }\n\n    //拼接配置文件参数\n    private List<Resource> getScripts(String propertyName, List<String> resources, String fallback) {\n        if (resources != null) {\n        \t//如果配置文件中shema配置项不为空则按指定文件执行\n            return this.getResources(propertyName, resources, true);\n        } else {\n            //如果配置文件中shema配置项为空则按默认配置执行 如shema.sql  ,传入fallback参数为文件名称\n            String platform = this.properties.getPlatform();\n            List<String> fallbackResources = new ArrayList();\n            fallbackResources.add(\"classpath*:\" + fallback + \"-\" + platform + \".sql\");\n            fallbackResources.add(\"classpath*:\" + fallback + \".sql\");\n            return this.getResources(propertyName, fallbackResources, false);\n        }\n    }\n\n\n    //执行方法\n    private void runScripts(List<Resource> resources, String username, String password) {\n        if (!resources.isEmpty()) {\n            ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n            populator.setContinueOnError(this.properties.isContinueOnError());\n            populator.setSeparator(this.properties.getSeparator());\n            if (this.properties.getSqlScriptEncoding() != null) {\n                populator.setSqlScriptEncoding(this.properties.getSqlScriptEncoding().name());\n            }\n\n            Iterator var5 = resources.iterator();\n\n            while(var5.hasNext()) {\n                Resource resource = (Resource)var5.next();\n                populator.addScript(resource);\n            }\n\n            DataSource dataSource = this.dataSource;\n            if (StringUtils.hasText(username) && StringUtils.hasText(password)) {\n                dataSource = DataSourceBuilder.create(this.properties.getClassLoader()).driverClassName(this.properties.determineDriverClassName()).url(this.properties.determineUrl()).username(username).password(password).build();\n            }\n\n            DatabasePopulatorUtils.execute(populator, dataSource);\n        }\n    }\n}\n\n```\n\n如此 我们也就对该配置及实现了解了个大概！！\n\n\n\n## 数据源连接池\n\nspringboot默认配置配置源选择有很多，在这里我就用druid阿里数据源连接池来做示例\n\n### 具体操作\n\n#### 配置文件\n\npom.xml\n\n```xml\n<!-- 阿里数据源 -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.8</version>\n</dependency>\n\n<!-- 引入日志，否则数据源启动报错 -->\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\napplication.yml\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/chapter5_jdbc?serverTimezone=UTC\n    username: root\n    password: 1234\n    # 自动建表\n    schema-username: root\n    schema-password: 1234\n    initialization-mode: embedded\n    schema:\n      - classpath*:employee.sql\n      - classpath*:schema.sql\n      \n    # 指定数据源为阿里连接池数据源\n    type: com.alibaba.druid.pool.DruidDataSource\n    #   数据源其他配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n\n\n```\n\n#### 自定义数据源配置类&监控管理后台\n\n```java\npackage com.shawn.chapter5.config;\n\n@Configuration\npublic class DruidConfig {\n\n    /**\n    *\n    *\t绑定配置文件各项参数，并写入容器中\n    */\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Bean\n    public DruidDataSource druidDataSource(){\n        return new DruidDataSource();\n    }\n\n    /**\n     * 配置Druid的监控\n     * 配置一个管理后台的Servlet\n     * @return\n     */\n    @Bean\n    public ServletRegistrationBean statViewServlet(){\n        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\n                \"/druid/*\");\n        Map<String,String> initParams = new HashMap<>();\n        {\n            //登陆名密码\n            initParams.put(\"loginUsername\",\"admin\");\n            initParams.put(\"loginPassword\",\"1234\");\n            //白名单\n            initParams.put(\"allow\",\"localhost\");\n            //黑名单\n            initParams.put(\"deny\",\"\");\n        }\n        bean.setInitParameters(initParams);\n        return bean;\n    }\n\n    /**\n     * 配置web监控的拦截器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean webStatFilter(){\n        FilterRegistrationBean registrationBean = new FilterRegistrationBean();\n        {\n            registrationBean.setFilter(new WebStatFilter());\n            //配置属型\n            Map<String,String> initParam = new HashMap<>();\n            {\n                //拦截白名单\n                initParam.put(\"exclusions\",\"*.js,*.css\");\n            }\n            registrationBean.setInitParameters(initParam);\n            //拦截配置 /* 拦截所有\n            registrationBean.setUrlPatterns(Arrays.asList(\"/*\"));\n        }\n        return registrationBean;\n    }\n\n}\n```\n\n至此，数据源与监控管理后台配置完成 打开浏览器测试\n\n{% asset_img 1564212299638.png %}\n\n大功告成！！\n\n\n\n## CRUD操作\n\n### 数据表\n\n首先数据库建表\n\n```sql\nCREATE TABLE `t_user` (\n  `id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键自增',\n  `username` varchar(50) NOT NULL COMMENT '用户名',\n  `password` varchar(50) NOT NULL COMMENT '密码',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';\n```\n\n### entity类\n\n**User**\n\n```java\npackage com.shawn.chapter5.entity;\n\npublic class User {\n    private int id;\n    private String username;\n    private String password;\n\n    public User() {\n    }\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n    \n    省略getter setter\n}\n```\n\n### restful 风格接口\n\n偷个小懒，就省略了**service**,**dao**层代码，直接在`controller`层使用`jdbcTemplate`进行数据库操作，**这种写法非常不规范，各位童鞋千万不要学哦**\n\n**UserController**\n\n```java\npackage com.shawn.chapter5.controller;\n\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @GetMapping\n    public List<User> queryUsers() {\n        // 查询所有用户\n        String sql = \"select * from t_user\";\n        return jdbcTemplate.query(sql, new Object[]{}, new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // 根据主键ID查询\n        String sql = \"select * from t_user where id = ?\";\n        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public int delUser(@PathVariable Long id) {\n        // 根据主键ID删除用户信息\n        String sql = \"DELETE FROM t_user WHERE id = ?\";\n        return jdbcTemplate.update(sql, id);\n    }\n\n    @PostMapping\n    public int addUser(@RequestBody User user) {\n        // 添加用户\n        String sql = \"insert into t_user(username, password) values(?, ?)\";\n        return jdbcTemplate.update(sql, user.getUsername(), user.getPassword());\n    }\n\n\n    @PutMapping(\"/{id}\")\n    public int editUser(@PathVariable Long id, @RequestBody User user) {\n        // 根据主键ID修改用户信息\n        String sql = \"UPDATE t_user SET username = ? ,password = ? WHERE id = ?\";\n        return jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), id);\n    }\n}\n```\n\n\n\n\n\n## 测试\n\n由于上面的接口是 restful 风格的接口，添加和修改无法通过浏览器完成，所以需要我们自己编写`junit`或者使用`postman`之类的工具。\n\n创建单元测试`Chapter4ApplicationTests`，通过`TestRestTemplate`模拟**GET、POST、PUT、DELETE等请求操作**\n\n```java\npackage com.shawn.chapter5;\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Chapter5JdbcApplicationTests {\n\n    private static final Logger log = LoggerFactory.getLogger(Chapter5JdbcApplicationTests.class);\n\n    @Autowired\n    private TestRestTemplate testRestTemplate;\n\n    @Test\n    public void testInsert() throws Exception {\n        testRestTemplate.postForEntity(\"http://localhost:\" + 8080 + \"/users\", new User(\"user1\", \"pass1\"), Integer.class);\n        log.info(\"[添加用户成功]\\n\");\n        // TODO 如果是返回的集合,要用 exchange 而不是 getForEntity ，后者需要自己强转类型\n        final List<User> body = testRestTemplate.exchange(\"http://localhost:\" + 8080 + \"/users\", HttpMethod.GET\n                , null, new ParameterizedTypeReference<List<User>>(){}).getBody();\n        log.info(\"[查询所有] - [{}]\\n\", body);\n        int userId = body.get(0).getId();\n        ResponseEntity<User> response3 = testRestTemplate.getForEntity(\"http://localhost:\" + 8080 + \"/users/{id}\", User.class, userId);\n        log.info(\"[主键查询] - [{}]\\n\", response3.getBody());\n        testRestTemplate.put(\"http://localhost:\" + 8080 + \"/users/{id}\", new User(\"user11\", \"pass11\"), userId);\n        log.info(\"[修改用户成功]\\n\");\n        testRestTemplate.delete(\"http://localhost:\" + 8080 + \"/users/{id}\", userId);\n        log.info(\"[删除用户成功]\");\n    }\n\n}\n\n```\n\n\n\n## 相关资料\n\n[crud部分参考博文](https://blog.battcn.com/2018/05/07/springboot/v2-orm-jdbc/)\n\n\n\n[TestRestTemplate官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-rest-templates-test-utility)\n\n\n\n[jdbcTemplate官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-using-jdbc-template)\n\n\n\n[博客项目地址](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter5-jdbc)","tags":["java","Spring","mysql","jdbcTemplate"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第五篇：Spring MVC配置及原理 & 拦截器应用","url":"/2019/07/26/初识SpringBoot丨第五篇:Spring-MVC配置及原理-拦截器应用/","content":"> Spring Boot有许多包含Spring MVC的启动器。请注意，一些启动器包含对Spring MVC的依赖，而不是直接包含它。本节回答有关Spring MVC和Spring Boot的常见问题。\n\nSpring Boot为Spring MVC提供自动配置，适用于大多数应用程序。\n\n<!-- more -->\n\n自动配置在Spring的默认值之上添加了以下功能：\n\n- 包含`ContentNegotiatingViewResolver`和`BeanNameViewResolver`豆类。\n\n- 支持提供静态资源，包括对WebJars的支持（ [官方文档介绍](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content)））。\n\n- 自动注册`Converter`，`GenericConverter`和`Formatter`bean类。\n\n  - Converter：转换器；  public String hello(User user)：类型转换使用Converter\n\n  - `Formatter`  格式化器；  2017.12.17===Date；\n\n    ```java\n    \t@Bean\n    \t\t@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则\n    \t\tpublic Formatter<Date> dateFormatter() {\n    \t\t\treturn new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件\n    \t\t}\n    ```\n\n    ==自己添加的格式化器转换器，我们只需要放在容器中即可==\n\n    \n\n- 支持`HttpMessageConverters`（ [官方文档介绍](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-message-converters)）。\n\n  - HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json；\n\n  - `HttpMessageConverters` 是从容器中确定；获取所有的HttpMessageConverter；\n\n    ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==\n\n  \n\n- 自动注册`MessageCodesResolver`（ [官方文档介绍](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-message-codes)）。\n\n- 静态`index.html`支持。\n\n- 自定义`Favicon`支持（[官方文档介绍](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-favicon)）。\n\n- 自动使用`ConfigurableWebBindingInitializer`bean（ [官方文档介绍](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-web-binding-initializer)）。\n\n  ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==\n\n  ```\n  初始化WebDataBinder；\n  请求数据=====JavaBean；\n  ```\n\n如果您想保留Spring Boot MVC功能并且想要添加其他 [MVC配置](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc)（拦截器，格式化程序，视图控制器和其他功能），您可以添加自己的`@Configuration`类类型`WebMvcConfigurer`但**不需要** `@EnableWebMvc`。如果您希望提供，或的 自定义实例`RequestMappingHandlerMapping`，则可以声明 实例以提供此类组件。`RequestMappingHandlerAdapter` `ExceptionHandlerExceptionResolver` `WebMvcRegistrationsAdapter`\n\n如果您想完全控制Spring MVC，可以添加自己的`@Configuration` 注释`@EnableWebMvc`。\n\n\n\n## 扩展SpringMvc\n\n在springboot默认mvc配置下，再自己扩展其配置工功能；最终效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\n\n### 1、编写一个springmvc.xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n\n    <mvc:view-controller path=\"/hello\" view-name=\"success\"/>\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/hello\"/>\n            <bean></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n</beans>\n```\n\n\n\n### 编写一个配置类（@Configuration）\n\n改配置类是WebMvcConfigurationSupport类型；不能标注@EnableWebMvc（使用该注解代表将springboot默认配置失效）;\n\nspringboot 2.0前：\n\n```java\n@Configuration\npublic class MyMvcConfig extends WebMvcAutoConfigurationAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        //浏览器发送 /shawn请求来到success页面\n        registry.addViewController(\"/shawn\").setViewName(\"success\");\n    }\n}\n```\n\nspring boot2.0  继承WebMvcAutoConfigurationAdapter类已经过时:\n\n```java\n//实现WebMvcConfigurer可以来扩展SpringMVC的功能（建议）\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        //浏览器发送 /shawn请求来到success页面\n        registry.addViewController(\"/shawn\").setViewName(\"success\");\n    }\n}\n\nor\n\n//继承WebMvcConfigurationSupport可以来扩展SpringMVC的功能,同时也相当于使用了@EnableWebMvc注解，springboot默认配置全部失效\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        //浏览器发送 /shawn请求来到success页面\n        registry.addViewController(\"/shawn\").setViewName(\"success\");\n    }\n}\n\n```\n\n\n\n原理：\n\n#### 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类\n\n#### 2）、在做其他自动配置时会导入；@Import({WebMvcAutoConfiguration . EnableWebMvcConfiguration .class})\n\n{% asset_img 1564040688664.png %}\n\n**例如参照添加视图方法addViewControllers功能来入手**\n\n1. 从源码看EnableWebMvcConfiguration 继承了DelegatingWebMvcConfiguration类\n\n```\n@Configuration\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n\n    private final WebMvcConfigurerComposite configurers = new  WebMvcConfigurerComposite();\n    public DelegatingWebMvcConfiguration() {\n    }\n\n    //从容器中获取所有ebMvcConfigurer\n    @Autowired(\n        required = false\n    )\n    public void setConfigurers(List<WebMvcConfigurer> configurers) {\n        if (!CollectionUtils.isEmpty(configurers)) {\n            this.configurers.addWebMvcConfigurers(configurers);\n        }\n\n    }\n\n    //设置视图方法\n    protected void addViewControllers(ViewControllerRegistry registry) {\n        this.configurers.addViewControllers(registry);\n    }\n\n    ...\n}\n```\n\n2. 点击该类addViewControllers 实现方法，进入WebMvcConfigurerComposite类中\n\n   ```java\n   class WebMvcConfigurerComposite implements WebMvcConfigurer {\n       private final List<WebMvcConfigurer> delegates = new ArrayList();\n       \n       public void addViewControllers(ViewControllerRegistry registry) {\n           Iterator var2 = this.delegates.iterator();\n   \t\t//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；\n           while(var2.hasNext()) {\n               WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();\n               delegate.addViewControllers(registry);\n           }\n   \n       }\n   ```\n\n   \n\n#### 3）、容器中所有的WebMvcConfigurer都会一起起作用；\n\n#### 4）、我们的配置类也会被调用；\n\n至此，扩展配置内容结束\n\n\n\n## 全面接管SpringMVC\n\n这一操作将SpringBoot对SpringMVC的自动配置全部废弃，所有配置都由我们自己配置；(不建议，此部分内容只是说明springboot提供了该操作场景)\n\n### 实际实现\n\n实现起来也很简单，**我们需要在配置类中添加@EnableWebMvc即可；**\n\n```java\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@EnableWebMvc\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n       // super.addViewControllers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addViewController(\"/shawn\").setViewName(\"success\");\n    }\n}\n```\n\n原理：\n\n为什么@EnableWebMvc自动配置就失效了；我们首先来看看其源码是如何配置的。\n\n1）@EnableWebMvc的核心\n\n```java\n//导入了DelegatingWebMvcConfiguration类\n@Import(DelegatingWebMvcConfiguration.class)\npublic @interface EnableWebMvc {\n```\n\n2）、DelegatingWebMvcConfiguration类\n\n```java\n//继承了WebMvcConfigurationSupport类\n@Configuration\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n```\n\n3）、WebMvcConfigurationSupport类\n\n```java\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,\n\t\tWebMvcConfigurerAdapter.class })\n//该注解标识如果容器中没有这个组件的时候，这个自动配置类才生效\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration .class ,\n\t\tValidationAutoConfiguration .class })\npublic class WebMvcAutoConfiguration {\n```\n\n4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\n\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；\n\n\n\n\n## 自定义@ResponseBody渲染\n\nSpring用于`HttpMessageConverters`渲染`@ResponseBody`（或响应 `@RestController`）。您可以通过在Spring Boot上下文中添加适当类型的bean来提供其他转换器。如果您添加的bean是默认包含的类型（例如`MappingJackson2HttpMessageConverter`JSON转换），则它将替换默认值。`HttpMessageConverters`提供了类型的便利bean， 如果您使用默认的MVC配置，它始终可用。它有一些有用的方法来访问默认和用户增强的消息转换器（例如，如果要手动将它们注入自定义，它可能很有用`RestTemplate`）。\n\n与正常的MVC使用情况一样，`WebMvcConfigurer`您提供的任何bean也可以通过覆盖该`configureMessageConverters`方法来提供转换器。但是，与普通的MVC不同，您只能提供所需的其他转换器（因为Spring Boot使用相同的机制来提供其默认值）。最后，如果您通过提供自己的`@EnableWebMvc`配置选择退出Spring Boot默认MVC 配置，则可以完全控制并使用`getMessageConverters`from 手动完成所有操作 `WebMvcConfigurationSupport`。\n\n有关[`WebMvcAutoConfiguration`](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java) 更多详细信息，请参阅 源代码。\n\n\n\n## 处理多部分文件上载\n\nSpring Boot包含Servlet 3 `javax.servlet.http.Part`API以支持上传文件。默认情况下，Spring Boot配置Spring MVC，每个文件的最大大小为1MB，单个请求中的文件数据最大为10MB。您可以覆盖这些值，中间数据的存储位置（例如，到`/tmp` 目录），以及使用`MultipartProperties`类中公开的属性将数据刷新到磁盘的阈值。例如，如果要指定文件不受限制，请将`spring.servlet.multipart.max-file-size`属性设置为`-1`。\n\n当您希望在Spring MVC控制器处理程序方法中接收多部分编码文件数据作为`@RequestParam`类型的注释参数时，多部分支持很有用`MultipartFile`。\n\n有关[`MultipartAutoConfiguration`](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java) 详细信息，请参阅 源代码。\n\n| ![[注意]](note.png)                                          |\n| ------------------------------------------------------------ |\n| 建议使用容器的内置支持进行分段上传，而不是引入其他依赖项，例如Apache Commons File Upload。 |\n\n\n\n## 关闭Spring MVC DispatcherServlet\n\n默认情况下，所有内容都是从应用程序的根目录（`/`）提供的。如果您希望映射到其他路径，可以按如下方式配置：\n\n```\nspring.mvc.servlet.path = / acme\n```\n\n如果你有额外的servlet，你可以声明一个`@Bean`类型`Servlet`或 `ServletRegistrationBean`每个servlet ，Spring Boot会将它们透明地注册到容器中。因为servlet是以这种方式注册的，所以可以将它们映射到`DispatcherServlet`不调用它的子上下文。\n\n配置`DispatcherServlet`你自己是不寻常的，但如果你真的需要这样做，还必须提供一种 `@Bean`类型`DispatcherServletPath`来提供自定义的路径`DispatcherServlet`。\n\n  \n## 拦截器配置\n\n**模拟场景：**\n\n​\t登陆时，对没有用户session的操作进行拦截调到首页\n\n\n\n### 实现\n\n编写拦截器类LoginHandlerInterceptor，实现HandlerInterceptor接口\n\n```java\n/**\n * 登陆检查，\n */\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\n    //目标方法执行之前\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        Object user = request.getSession().getAttribute(\"loginUser\");\n        if(user == null){\n            //未登陆，返回登陆页面\n            request.setAttribute(\"msg\",\"没有权限请先登陆\");\n            request.getRequestDispatcher(\"/index.html\").forward(request,response);\n            return false;\n        }else{\n            //已登陆，放行请求\n            return true;\n        }\n\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n将该拦截器添加入容器\n\nmvc自动配置类MyMvcConfig中重写拦截器方法写入规则\n\n```java\npackage com.shawn.chapter4.config;\n\n\n@Configuration\n//@EnableWebMvc\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n\n    //重写方法写入拦截规则\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\")\n                .excludePathPatterns(\"/\",\"/index\",\"/login\");\n    }\n\n}\n```\n\n\n## 相关资料\n\n[springboot官方文档](https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications)\n\n\n[git相关项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter4-web)","tags":["java","Spring","SpringMVC"],"categories":["SpringBoot"]},{"title":" 初识SpringBoot丨第四篇：整合thymeleaf & 国际化配置","url":"/2019/07/26/初识SpringBoot丨第四篇:整合thymeleaf-国际化配置/","content":"> 模板引擎（这里特指用于Web开发的模板引擎）是为了使[用户界面](https://baike.baidu.com/item/用户界面)与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的[HTML](https://baike.baidu.com/item/HTML)文档。\n\n<!-- more -->\n\n目前使用广泛的模板引擎有JSP、Velocity、Freemarker、Thymeleaf等。。SpringBoot推荐使用的分别如下图所示 thymeleaf、freemark、groovy...\n\n{% asset_img 1564115689768.png %}\n\n下面我就介绍其中thymeleaf的相关整合\n\n## 引入thymeleaf\n\n在pom文件中引入\n\n```xml\n<!-- 引入 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    2.1.6\n</dependency>\n\n<!-- 切换thymeleaf版本 -->\n<properties>\n\t\t<thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>\n\t\t<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->\n\t\t<!-- thymeleaf2   layout1-->\n\t\t<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\n</properties>\n\nor\n\n<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->\n<thymeleaf-spring5.version>3.0.9.RELEASE</thymeleaf-spring5.version>\n<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layoutdialect.version>\n```\n\n\n\n## Thymeleaf使用\n\n在springboot中默认为thymeleaf配置了相关配置\n\n```java\n@ConfigurationProperties(prefix = \"spring.thymeleaf\")\npublic class ThymeleafProperties {\n\n    //默认编码\n\tprivate static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\");\n\n    //文本类型\n\tprivate static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\");\n\n    //加载地址\n\tpublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n\t\n    //默认后缀\n\tpublic static final String DEFAULT_SUFFIX = \".html\";\n```\n\n有了上方默认配置，只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；\n\n\n\n### 1、使用\n\n1、在html文件中导入thymeleaf的名称空间\n\n```html\n<!-- 引入该名称空间 加入代码提示及规范 -->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n\n\n2、使用thymeleaf语法\n\n接口：\n\n```java\n@RequestMapping(value = \"/success\")\npublic String success(Map<String,Object> map){\n    map.put(\"hello\",\"<h1>success</h1>\");\n    map.put(\"users\", Arrays.asList(\"zhangsan\",\"lisi\",\"wangwu\"));\n    return \"success\";\n}\n```\n\n**success.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <h1>Success！！</h1>\n\n    <hr/>\n    <!-- th:text 将div里面的文本内容设置为变量值 ,不转义特殊字符\n         th:utext 将div里面的文本内容设置为变量值 ,转义特殊字符\n        th:id 将div的id值设为该变量\n        th:class 将div的class属性设置为该变量\n    -->\n    <div th:text=\"${hello}\" th:id=\"${hello}\" th:class=\"${hello}\"></div>\n    <div th:utext=\"${hello}\" th:id=\"${hello}\" th:class=\"${hello}\"></div>\n\n    <hr>\n    <!-- th:each 每次比遍历都会生成一个新的标签 -->\n    <!--：3个h4标签-->\n    <h4 th:text=\"${user}\" th:each=\"user : ${users}\"></h4>\n\n    <hr>\n    <h4>\n        <!--：3个span标签-->\n        <span th:text=\"${user}\" th:each=\"user : ${users}\"></span>\n    </h4>\n</body>\n</html>\n```\n\n浏览器访问结果：\n\n{% asset_img 1564035464645.png %}\n\n\n\n### 2、语法规则\n\n1）、th:text；改变当前元素里面的文本内容；\n\n​\tth：任意html属性；来替换原生属性的值\n\n{% asset_img 2018-02-04_123955.png %}\n\n\n\n2）、表达式？\n\n```properties\nSimple expressions:（表达式语法）\n    Variable Expressions: ${...}：获取变量值；OGNL；\n    \t\t1）、获取对象的属性、调用方法\n    \t\t2）、使用内置的基本对象：\n    \t\t\t#ctx : the context object.\n    \t\t\t#vars: the context variables.\n                #locale : the context locale.\n                #request : (only in Web Contexts) the HttpServletRequest object.\n                #response : (only in Web Contexts) the HttpServletResponse object.\n                #session : (only in Web Contexts) the HttpSession object.\n                #servletContext : (only in Web Contexts) the ServletContext object.\n                \n                ${session.foo}\n            3）、内置的一些工具对象：\n#execInfo : information about the template being processed.\n#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.\n#uris : methods for escaping parts of URLs/URIs\n#conversions : methods for executing the configured conversion service (if any).\n#dates : methods for java.util.Date objects: formatting, component extraction, etc.\n#calendars : analogous to #dates , but for java.util.Calendar objects.\n#numbers : methods for formatting numeric objects.\n#strings : methods for String objects: contains, startsWith, prepending/appending, etc.\n#objects : methods for objects in general.\n#bools : methods for boolean evaluation.\n#arrays : methods for arrays.\n#lists : methods for lists.\n#sets : methods for sets.\n#maps : methods for maps.\n#aggregates : methods for creating aggregates on arrays or collections.\n#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).\n\n    Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；\n    \t补充：配合 th:object=\"${session.user}：\n   <div th:object=\"${session.user}\">\n    <p>Name: <span th:text=\"*{firstName}\">Sebastian</span>.</p>\n    <p>Surname: <span th:text=\"*{lastName}\">Pepper</span>.</p>\n    <p>Nationality: <span th:text=\"*{nationality}\">Saturn</span>.</p>\n    </div>\n    \n    Message Expressions: #{...}：获取国际化内容\n    Link URL Expressions: @{...}：定义URL；\n    \t\t@{/order/process(execId=${execId},execType='FAST')}\n    Fragment Expressions: ~{...}：片段引用表达式\n    \t\t<div th:insert=\"~{commons :: main}\">...</div>\n    \t\t\nLiterals（字面量）\n      Text literals: 'one text' , 'Another one!' ,…\n      Number literals: 0 , 34 , 3.0 , 12.3 ,…\n      Boolean literals: true , false\n      Null literal: null\n      Literal tokens: one , sometext , main ,…\nText operations:（文本操作）\n    String concatenation: +\n    Literal substitutions: |The name is ${name}|\nArithmetic operations:（数学运算）\n    Binary operators: + , - , * , / , %\n    Minus sign (unary operator): -\nBoolean operations:（布尔运算）\n    Binary operators: and , or\n    Boolean negation (unary operator): ! , not\nComparisons and equality:（比较运算）\n    Comparators: > , < , >= , <= ( gt , lt , ge , le )\n    Equality operators: == , != ( eq , ne )\nConditional operators:条件运算（三元运算符）\n    If-then: (if) ? (then)\n    If-then-else: (if) ? (then) : (else)\n    Default: (value) ?: (defaultvalue)\nSpecial tokens:\n    No-Operation: _ \n```\n\n\n\n### 3、优化配置\n\n> 模板热部署\n\n在 `IntelliJ IDEA` 中使用 `thymeleaf` 模板的时候，发现每次修改静态页面都需要重启才生效，这点是很不友好的，百度了下发现原来是默认配置搞的鬼，为了提高响应速度，默认情况下会缓存模板。如果是在开发中请**将spring.thymeleaf.cache 属性设置成 false**。在每次修改静态内容时**按Ctrl+Shift+F9**即可重新加载了…\n\n\n\n> application配置项\n\n{% asset_img 1564050435497.png %}\n\n\n\n## 国际化配置\n\n- 编写国际化配置文件；\n\n- 使用ResourceBundleMessageSource管理国际化资源文件\n\n- 在页面使用fmt:message取出国际化内容\n\n同样的 ，springboot也已经为我们配置好了挂你国际化资源文件的组件\n\n如下为SpringBoot的自动配置文件部分代码：\n\n```java\n@ConfigurationProperties(prefix = \"spring.messages\") //代表我们在application 文件配置此相关配置的前缀\npublic class MessageSourceAutoConfiguration {\n    \n    /**\n\t * Comma-separated list of basenames (essentially a fully-qualified classpath\n\t * location), each following the ResourceBundle convention with relaxed support for\n\t * slash based locations. If it doesn't contain a package qualifier (such as\n\t * \"org.mypackage\"), it will be resolved from the classpath root.\n\t */\n\tprivate String basename = \"messages\";  \n    //我们的配置文件可以直接放在类路径下叫messages.properties；\n    \n    @Bean\n\tpublic MessageSource messageSource() {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tif (StringUtils.hasText(this.basename)) {\n            //设置国际化资源文件的基础名（去掉语言国家代码的）\n\t\t\tmessageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\tStringUtils.trimAllWhitespace(this.basename)));\n\t\t}\n\t\tif (this.encoding != null) {\n            //配置默认编码\n\t\t\tmessageSource.setDefaultEncoding(this.encoding.name());\n\t\t}\n\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\tmessageSource.setCacheSeconds(this.cacheSeconds);\n\t\tmessageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);\n\t\treturn messageSource;\n\t}\n```\n\n\n\n### 1、编写国际化配置文件，抽取页面需要显示的国际化消息\n\n首先创建一个存放国际化配置文件的文件夹，其中配置文件名中只需要包含国际化编码信息（如：en_US、zh_CN等...) idea则会自动帮我们建立国际化视图\n\n{% asset_img 1564117252980.png %}\n\n\n\n### 2、文本配置\n\nspringboot相关配置文件配置\n\napplication.properties\n\n```properties\n#springboot已经为我们配置好了默认配置  如下只是示例\nspring.messages.basename=i18n.login\nspring.messages.always-use-message-format=false\nspring.messages.encoding=utf-8\n```\n\n\n\n### 3、在html中使用thymeleaf获取国际化配置的值\n\nindex.html\n\n```html\n<!-- 引入格式 #{besename.value} 如#{login.tip} -->\n<h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\n\t\t\t<p style=\"color: red;\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"></p>\n\t\t\t<label class=\"sr-only\" th:text=\"#{login.username}\">Username</label>\n\t\t\t<input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\">\n\t\t\t<label class=\"sr-only\" th:text=\"#{login.password}\">Password</label>\n\t\t\t<input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required=\"\" th:placeholder=\"#{login.password}\" >\n\t\t\t<div class=\"checkbox mb-3\">\n\t\t\t\t<label>\n          <input type=\"checkbox\" value=\"remember-me\" />[[#{login.remember}]]\n        </label>\n\t\t\t</div>\n\t\t\t<button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\n\t\t\t<p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n\n<!--  简单例子 切换请求-->\n\t\t\t<a class=\"btn btn-sm\" th:href=\"@{/index.html(l='zn_CN')}\">中文</a>\n\t\t\t<a class=\"btn btn-sm\" th:href=\"@{/index.html(l='en_US')}\">English</a>\n\t\t</form>\n```\n\nIndexController 文件映射controller层\n\n```java\n@Controller\npublic class IndexController {\n\n    @RequestMapping(value = {\"/\",\"/index\"})\n    public String Index(){\n        return \"index\";\n\n    }\n```\n\n自定义国际化配置类\n\n```java\npackage com.shawn.chapter4.component;\n\npublic class MyLocaleResolver implements LocaleResolver {\n    @Override\n    public Locale resolveLocale(HttpServletRequest httpServletRequest) {\n        String l = httpServletRequest.getParameter(\"l\");\n        Locale locale = Locale.getDefault();\n        if(!StringUtils.isEmpty(l)){\n            String[] s = l.split(\"_\");\n            locale = new Locale(s[0],s[1]);\n        }\n        return locale;\n    }\n```\n\n**将自定义配置类加入bean容器中**\n\nMyMvcConfig 自定义配置类\n\n```java\npackage com.shawn.chapter4.config;\n\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n    ...\n        \n     @Bean\n    public LocaleResolver localeResolver(){\n        return new MyLocaleResolver();\n    }\n}\n```\n\n如此国际化配置就配置完成了\n\n\n\n**配置原理**：\n\n**spring boot在会在启动时加载所有国际化配置类**\n\nWebMvcAutoConfiguration web相关自动配置类（后续文章会详细描述）：\n\n```java\n@Configuration\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n@AutoConfigureOrder(-2147483638)\n@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\npublic class WebMvcAutoConfiguration {\n\n\t\t@Bean\n        @ConditionalOnMissingBean\n        @ConditionalOnProperty(\n            prefix = \"spring.mvc\",\n            name = {\"locale\"}\n        )\n    \t//国际化相关配置内容\n        public LocaleResolver localeResolver() {\n            if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) {\n                return new FixedLocaleResolver(this.mvcProperties.getLocale());\n            } else {\n                AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();\n                localeResolver.setDefaultLocale(this.mvcProperties.getLocale());\n                return localeResolver;\n            }\n        }\n}\n\n\n//如上所示 只需要实现LocaleResolver接口即可表明这是一个国际化配置容器\npublic class AcceptHeaderLocaleResolver implements LocaleResolver {\n\n}\n```\n\n\n\n## 相关资料\n\n[springboot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html#howto-reload-thymeleaf-content)\n\n[github相关项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter4-web)","tags":["java","Spring","thymeleaf"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第三篇：日志相关整合","url":"/2019/07/24/初识SpringBoot丨第三篇:日志相关整合/","content":">Spring Boot使用[Commons Logging](https://commons.apache.org/logging)进行所有内部日志记录，但保留底层日志实现。为[Java Util Logging](https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html)，[Log4J2](https://logging.apache.org/log4j/2.x/)和 [Logback](https://logback.qos.ch/)提供了默认配置 。在每种情况下，记录器都预先配置为使用控制台输出，同时还提供可选的文件输出。  \n<!-- more -->\n默认情况下，如果使用“Starters”，则使用**Logback**进行日志记录。还包括适当的**Logback**路由，以确保使用**Java Util Logging**，**Commons Logging**，**Log4J**或**SLF4J**的依赖库都能正常工作。  \nJava有很多日志框架可供使用。如果以上列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。**springboot** 默认选用 **SLF4j**和**logback**；\n\n\n\n## SLF4j使用\n\n### 1、如何在系统中使用SLF4j   https://www.slf4j.org\n\n开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\n\n给系统里面导入slf4j的jar和  logback的实现jar\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(\"Hello World\");\n  }\n}\n```\n\n图示；\n\n{% asset_img concrete-bindings.png %}\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，**配置文件还是做成日志实现框架自己本身的配置文件；**\n\n### 2、遗留问题\n\n#### 统一日志记录\n\n{% asset_img legacy.png %}\n\n**如何让系统中所有的日志都统一到slf4j；**\n\n==1、将系统中其他日志框架先排除出去；==\n\n==2、用中间包来替换原有的日志框架；==\n\n==3、我们导入slf4j其他的实现==\n\n\n\n## SpringBoot日志关系\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter</artifactId>\n\t\t</dependency>\n```\n\n\n\nSpringBoot使用它来做日志功能；\n\n```xml\n![spring_boot_3-01](images/spring_boot_3-01.png)\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-logging</artifactId>\n\t\t</dependency>\n```\n\n底层依赖关系\n\n{% asset_img spring_boot_3-01.png %}\n\n关系总结：\n\n​\t1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录\n\n​\t2）、SpringBoot也把其他的日志都替换成了slf4j；\n\n​\t3）、使用了中间替换包\n\n```java\n@SuppressWarnings(\"rawtypes\")\npublic abstract class LogFactory {\n\n    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\";\n\n    static LogFactory logFactory = new SLF4JLogFactory();\n```\n\n{% asset_img 搜狗截图20180131221411.png %}\n\n\n\n​\t4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\n\n​\t\t\tSpring框架用的是commons-logging；\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-core</artifactId>\n\t\t\t<exclusions>\n                <!-- 移除Spring框架默认使用的commons-logging,从而使用logback的实现 -->\n\t\t\t\t<exclusion>\n\t\t\t\t\t<groupId>commons-logging</groupId>\n\t\t\t\t\t<artifactId>commons-logging</artifactId>\n\t\t\t\t</exclusion>\n\t\t\t</exclusions>\n\t\t</dependency>\n```\n\n**==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==**\n\n\n\n## 日志使用\n\n### 1、默认配置\n\nSpringBoot默认帮我们配置好了日志；\n\n#### **使用**：\n\n```java\n\t//记录器\n\tLogger logger = LoggerFactory.getLogger(getClass());\n\n\t@Test\n\tpublic void contextLoads() {\n\t\t//System.out.println();\n\n\t\t//日志的级别；\n\t\t//由低到高   trace<debug<info<warn<error\n\t\t//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n\t\tlogger.trace(\"这是trace日志...\");\n\t\tlogger.debug(\"这是debug日志...\");\n\t\t//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别\n\t\tlogger.info(\"这是info日志...\");\n\t\tlogger.warn(\"这是warn日志...\");\n\t\tlogger.error(\"这是error日志...\");\n\n\n\t}\n```\n\n#### SpringBoot修改日志的默认配置\n\n```\n    日志输出格式：\n\t\t%d表示日期时间，\n\t\t%thread表示线程名，\n\t\t%-5level：级别从左显示5个字符宽度\n\t\t%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \n\t\t%msg：日志消息，\n\t\t%n是换行符\n    -->\n    %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n```\n\n\n\n```properties\nlogging.level.com.atguigu=trace\n\n\n#logging.path=\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file=G:/springboot.log\n\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path=/spring/log\n\n#  在控制台输出的日志的格式\nlogging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n\n```\n\n| logging.file | logging.path | Example  | Description                        |\n| ------------ | ------------ | -------- | ---------------------------------- |\n| (none)       | (none)       |          | 只在控制台输出                     |\n| 指定文件名   | (none)       | my.log   | 输出日志到my.log文件               |\n| (none)       | 指定目录     | /var/log | 输出到指定目录的 spring.log 文件中 |\n\n### 2、指定配置\n\n如果需要使用指定日志框架则只要在类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不会使用他默认配置的了\n\n| Logging System          | Customization                                                |\n| ----------------------- | ------------------------------------------------------------ |\n| Logback                 | `logback-spring.xml`, `logback-spring.groovy`, `logback.xml` or `logback.groovy` |\n| Log4j2                  | `log4j2-spring.xml` or `log4j2.xml`                          |\n| JDK (Java Util Logging) | `logging.properties`                                         |\n\n\n\n#### SpringBoot高级功能Profile使用\n\n如：\n\n配置文件名为 ：logback.xml，该配置文件直接就被日志框架识别了；\n\n\n\nlogback-spring.xml**：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\n\n```xml\n<springProfile name=\"staging\">\n    <!-- configuration to be enabled when the \"staging\" profile is active -->\n  \t可以指定某段配置只在某个环境下生效\n</springProfile>\n\n```\n\n如：\n\n```xml\n<appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <!--\n        日志输出格式：\n\t\t\t%d表示日期时间，\n\t\t\t%thread表示线程名，\n\t\t\t%-5level：级别从左显示5个字符宽度\n\t\t\t%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \n\t\t\t%msg：日志消息，\n\t\t\t%n是换行符\n        -->\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <springProfile name=\"dev\">\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>\n            </springProfile>\n            <springProfile name=\"!dev\">\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n</pattern>\n            </springProfile>\n        </layout>\n    </appender>\n```\n\n\n\n如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\n\n `no applicable action for [springProfile]`\n\n\n\n## 切换日志框架\n\n可以按照slf4j的日志适配图，进行相关的切换（不建议切换，使用默认配置即可）；\n\n{% asset_img legacy.png %}\n\nslf4j+log4j的方式；\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n  <exclusions>\n    <exclusion>\n      <artifactId>logback-classic</artifactId>\n      <groupId>ch.qos.logback</groupId>\n    </exclusion>\n    <exclusion>\n      <artifactId>log4j-over-slf4j</artifactId>\n      <groupId>org.slf4j</groupId>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n</dependency>\n\n```\n\n\n\n切换为log4j2\n\n```xml\n   <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>spring-boot-starter-logging</artifactId>\n                    <groupId>org.springframework.boot</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```  \n\n## 相关资料\n\n\n​[SpringBoot官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html)\n\n\n​[本文相关项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter3-logging)\n\n","tags":["java","Spring","slf4j","log"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第二篇：配置文件详解","url":"/2019/07/19/初识SpringBoot丨第二篇:配置文件详解/","content":">springboot采纳了建立生产就绪spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。在一般情况下，我们不需要做太多的配置就能够让spring boot正常运行。在一些特殊的情况下，我们需要做修改一些配置，或者需要有自己的配置属性。\n\n<!-- more -->\n## 配置文件\n\nSpringBoot使用一个全局的配置文件，配置文件名是固定的；\n\n•application.properties\n\n•application.yml\n\n\n\n配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\n\n\n\nYAML（YAML Ain't Markup Language）\n\n> ​\tYAML  A Markup Language：是一个标记语言\n>\n> ​\tYAML   isn't Markup Language：不是一个标记语言；\n\n标记语言：\n\n> ​\t以前的配置文件；大多都使用的是  **xxxx.xml**文件；\n>\n> ​\tYAML：**以数据为中心**，比json、xml等更适合做配置文件；\n>\n> ​\tYAML：配置例子\n\n```yaml\nserver:\n  port: 8081\n```\n\n​\tXML：\n\n```xml\n<server>\n\t<port>8081</port>\n</server>\n```\n\n\n\n## YAML语法：\n\n### 1、基本语法\n\nk:(空格)v：表示一对键值对（空格必须有）；\n\n以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的\n\n```yaml\nserver:\n    port: 8081\n    path: /hello\n```\n\n属性和值也是大小写敏感；\n\n\n\n### 2、值的写法\n\n#### 字面量：普通的值（数字，字符串，布尔）\n\n​\tk: v：字面直接来写；\n\n​\t\t字符串默认不用加上单引号或者双引号；\n\n​\t\t\"\"：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\n\n​\t\t\t\tname:   \"zhangsan \\n lisi\"：输出；zhangsan 换行  lisi\n\n​\t\t''：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n\n​\t\t\t\tname:   ‘zhangsan \\n lisi’：输出；zhangsan \\n  lisi\n\n#### 对象、Map（属性和值）（键值对）：\n\n​\tk: v：在下一行来写对象的属性和值的关系；注意缩进\n\n​\t\t对象还是k: v的方式\n\n```yaml\nfriends:\n\t\tlastName: zhangsan\n\t\tage: 20\n```\n\n行内写法：\n\n```yaml\nfriends: {lastName: zhangsan,age: 18}\n```\n\n#### 数组（List、Set）：\n\n用- 值表示数组中的一个元素\n\n```yaml\npets:\n - cat\n - dog\n - pig\n```\n\n行内写法\n\n```yaml\npets: [cat,dog,pig]\n```\n\n\n\n## 配置文件值注入\n\n配置文件\n\n```yaml\nperson:\n    lastName: hello\n    age: 18\n    boss: false\n    birth: 2017/12/12\n    maps: {k1: v1,k2: 12}\n    lists:\n      - lisi\n      - zhaoliu\n    dog:\n      name: 小狗\n      age: 12\n```\n\njavaBean：\n\n```java\n/**\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\n * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\n *      prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射\n *\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\n *\n */\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Date birth;\n\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Dog dog;\n\n```\n\n\n\n我们可以导入配置文件处理器，以后编写配置就有提示了\n\n```xml\n<!--导入配置文件处理器，配置文件进行绑定就会有提示-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-configuration-processor</artifactId>\n\t\t\t<optional>true</optional>\n\t\t</dependency>\n```\n\n### 1、properties配置文件在idea中默认utf-8可能会乱码\n\n调整\n\n{% asset_img 搜狗截图20180130161620.png idea配置乱码 %}\n\n### 2、@Value获取值和@ConfigurationProperties获取值比较\n\n|                      | @ConfigurationProperties | @Value     |\n| -------------------- | ------------------------ | ---------- |\n| 功能                 | 批量注入配置文件中的属性 | 一个个指定 |\n| 松散绑定（松散语法） | 支持                     | 不支持     |\n| SpEL                 | 不支持                   | 支持       |\n| JSR303数据校验       | 支持                     | 不支持     |\n| 复杂类型封装         | 支持                     | 不支持     |\n\n配置文件yml还是properties他们都能获取到值；\n\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；\n\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；\n\n\n\n### 3、配置文件注入值数据校验\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"person\")\n@Validated\npublic class Person {\n\n   //lastName必须是邮箱格式\n    @Email\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n\n    private Date birth;\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Dog dog;\n```\n\n\n\n### 4、@PropertySource & @ImportResou & @Bean\n\n#### @**PropertySource**\n\n加载指定的配置文件；\n\n```java\n/**\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\n * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\n *      prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射\n *\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\n *  @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值；\n *\n */\n@PropertySource(value = {\"classpath:person.properties\"})\n@Component\n@ConfigurationProperties(prefix = \"person\")\n//@Validated\npublic class Person {\n\n    private String lastName;\n    \n    private Integer age;\n    \n    private Boolean boss;\n\n```\n\n\n\nperson.properties\n\n```xml 11\nperson:\n    lastName: hello\n    age: 18\n    boss: false\n```\n\n\n\n#### @**ImportResource**\n\n> 导入Spring的配置文件，让配置文件里面的内容生效；\n>\n> @**ImportResource**标注在一个配置类上\n\n```java\n@ImportResource(locations = {\"classpath:beans.xml\"})\n@SpringBootApplication\npublic class Chapter1Application {\n```\n\n **beans.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n    <bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"></bean>\n</beans>\n```\n\n\n\n#### SpringBoot推荐给容器中添加组件的方式\n\n推荐使用全注解的方式\n\n1、配置类**@Configuration**------>Spring配置文件\n\n2、使用**@Bean**给容器中添加组件\n\n```java\n/**\n * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件\n *\n * 在配置文件中用<bean><bean/>标签添加组件\n *\n */\n@Configuration\npublic class MyAppConfig {\n\n    //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n    @Bean\n    public HelloService helloService02(){\n        System.out.println(\"配置类@Bean给容器中添加组件了...\");\n        return new HelloService();\n    }\n}\n```\n\n## 配置文件占位符\n\n### 1、随机数\n\n```java\n${random.value}、${random.int}、${random.long}\n${random.int(10)}、${random.int[1024,65536]}\n\n```\n\n\n\n### 2、占位符获取之前配置的值，如果没有可以是用:指定默认值\n\n```properties\nperson.last-name=张三${random.uuid}\nperson.age=${random.int}\nperson.birth=2017/12/15\nperson.boss=false\nperson.maps.k1=v1\nperson.maps.k2=14\nperson.lists=a,b,c\nperson.dog.name=${person.hello:hello}_dog\nperson.dog.age=15\n```\n\n\n\n## Profile切换\n\n### 1、多Profile文件\n\n我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml\n\n默认使用application.properties的配置；\n\n\n\n### 2、yml支持多文档块方式\n\n```yml\nserver:\n  port: 8081\nspring:\n  profiles:\n    active: prod\n\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev\n\n\n---\n\nserver:\n  port: 8084\nspring:\n  profiles: prod  #指定属于哪个环境\n```\n\n\n\n\n\n### 3、激活指定profile\n\n​\t1、在配置文件中指定  spring.profiles.active=dev\n\n​\t2、命令行：\n\n​\t\tjava -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；\n\n​\t\t可以直接在测试的时候，配置传入命令行参数\n\n​\t3、虚拟机参数；\n\n​\t\t-Dspring.profiles.active=dev\n\n\n\n## 配置文件加载位置\n\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n\n–file:./config/\n\n–file:./\n\n–classpath:/config/\n\n–classpath:/\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n\nSpringBoot会从这四个位置全部加载主配置文件；**互补配置**；\n\n\n\n==我们还可以通过spring.config.location来改变默认的配置文件位置==\n\n**项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；**\n\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties\n\n## 外部配置加载顺序\n\n**==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==**\n\n**1.命令行参数**\n\n所有的配置都可以在命令行上进行指定\n\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc\n\n多个配置用空格分开； --配置项=值\n\n\n\n2.来自java:comp/env的JNDI属性\n\n3.Java系统属性（System.getProperties()）\n\n4.操作系统环境变量\n\n5.RandomValuePropertySource配置的random.*属性值\n\n\n\n==**由jar包外向jar包内进行寻找；**==\n\n==**优先加载带profile**==\n\n**6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件**\n\n**7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件**\n\n\n\n==**再来加载不带profile**==\n\n**8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件**\n\n**9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件**\n\n\n\n10.@Configuration注解类上的@PropertySource\n\n11.通过SpringApplication.setDefaultProperties指定的默认属性\n\n所有支持的配置加载来源；\n\n[参考官方文档](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config)\n\n## 自动配置原理\n\n配置文件到底能写什么？怎么写？自动配置原理；\n\n[配置文件能配置的属性参照](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties)\n\n\n\n### 1、**自动配置原理：**\n\n1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==\n\n**2）、@EnableAutoConfiguration 作用：**\n\n- 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？\n\n- 可以查看selectImports()方法的内容；\n\n- List<String> configurations = getCandidateConfigurations ( annotationMetadata , attributes);\n\n获取候选的配置\n  ```java\n    SpringFactoriesLoader.loadFactoryNames()\n    扫描所有jar包类路径下  META-INF/spring.factories\n    把扫描到的这些文件的内容包装成properties对象\n    从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中\n    \n  ```\n\n    \n\n**==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==**\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\\norg.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\n```\n\n每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；\n\n3）、每一个自动配置类进行自动配置功能；\n\n4）、以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理；\n\n```java\n@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中\n\n@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效\n\n@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\n\n@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的\n//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；\npublic class HttpEncodingAutoConfiguration {\n  \n  \t//他已经和SpringBoot的配置文件映射了\n  \tprivate final HttpEncodingProperties properties;\n  \n   //只有一个有参构造器的情况下，参数的值就会从容器中拿\n  \tpublic HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {\n\t\tthis.properties = properties;\n\t}\n  \n    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取\n\t@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？\n\tpublic CharacterEncodingFilter characterEncodingFilter() {\n\t\tCharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n\t\tfilter.setEncoding(this.properties.getCharset().name());\n\t\tfilter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));\n\t\tfilter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));\n\t\treturn filter;\n\t}\n```\n\n根据当前不同的条件判断，决定这个配置类是否生效？\n\n一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n\n\n\n\n\n\n\n5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类\n\n```java\n@ConfigurationProperties(prefix = \"spring.http.encoding\")  //从配置文件中获取指定的值和bean的属性进行绑定\npublic class HttpEncodingProperties {\n\n   public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n```\n\n\n\n\n\n**精髓：**\n\n​\t**1）、SpringBoot启动会加载大量的自动配置类**\n\n​\t**2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；**\n\n​\t**3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）**\n\n​\t**4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；**\n\n\n\nxxxxAutoConfigurartion：自动配置类；\n\n给容器中添加组件\n\nxxxxProperties:封装配置文件中相关属性；\n\n\n\n### 2、细节\n\n\n\n#### @Conditional派生注解（Spring注解版原生的@Conditional作用）\n\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |\n| ------------------------------- | ------------------------------------------------ |\n| @ConditionalOnJava              | 系统的java版本是否符合要求                       |\n| @ConditionalOnBean              | 容器中存在指定Bean；                             |\n| @ConditionalOnMissingBean       | 容器中不存在指定Bean；                           |\n| @ConditionalOnExpression        | 满足SpEL表达式指定                               |\n| @ConditionalOnClass             | 系统中有指定的类                                 |\n| @ConditionalOnMissingClass      | 系统中没有指定的类                               |\n| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |\n| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |\n| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |\n| @ConditionalOnWebApplication    | 当前是web环境                                    |\n| @ConditionalOnNotWebApplication | 当前不是web环境                                  |\n| @ConditionalOnJndi              | JNDI存在指定项                                   |\n\n**自动配置类必须在一定的条件下才能生效；**\n\n我们怎么知道哪些自动配置类生效；\n\n**我们可以通过启用  debug=true属性；来让控制台打印自动配置报告**，这样我们就可以很方便的知道哪些自动配置类生效；\n\n```java\n=========================\nAUTO-CONFIGURATION REPORT\n=========================\n\n\nPositive matches:（自动配置类启用的）\n-----------------\n\n   DispatcherServletAutoConfiguration matched:\n      - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)\n      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)\n        \n    \nNegative matches:（没有启动，没有匹配成功的自动配置类）\n-----------------\n\n   ActiveMQAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)\n\n   AopAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)\n        \n```","tags":["java","Spring","properties","yaml"],"categories":["SpringBoot"]},{"title":"初识SpringBoot丨第一篇：创建一个SpringBoot工程","url":"/2019/07/12/初识SpringBoot丨第一篇:创建一个SpringBoot工程/","content":"\n\n> `SpringBoot` 是为了简化 `Spring` 应用的创建、运行、调试、部署等一系列问题而诞生的产物，**自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程**\n\n<!-- more -->\n\n\n## 环境准备\n\n> –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version \"1.8.0_112\"\n>\n> –maven3.x：maven 3.3以上版本；Apache Maven 3.5\n>\n> –IntelliJIDEA2018：IntelliJ IDEA 2018 x64 或者 STS\n>\n> –SpringBoot 1.5.9.RELEASE：1.5.9；\n\n \n\n### 1、MAVEN设置\n\n给maven 的settings.xml配置文件的profiles标签添加\n\n```xml\n<profile>\n  <id>jdk-1.8</id>\n  <activation>\n    <activeByDefault>true</activeByDefault>\n    <jdk>1.8</jdk>\n  </activation>\n  <properties>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n  </properties>\n</profile>\n```\n\n\n\n### 2、 IDEA设置\n\n将整合maven进来；\n{% asset_img 搜狗截图20180129151045.png %} \n\n\n\n{% asset_img 搜狗截图20180129151112.png %} \n\n\n\n## 创建工程\n\n\n\n> ### 我们选择使用`IDEA`提供的`Spring Initializr(官方的构建插件，需要联网)`\n\n![第一步](https://image.battcn.com/article/images/20180420/springboot/v2-Introducing/2.png)\n\n\n\n### 填写项目基本信息\n\n- **Group：** 组织ID，一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为 `org、com、cn`等等，其中 **org为非营利组织，com为商业组织**。如阿里、淘宝（com.alibaba/com.taobao）\n\n- **Artifact:** 唯一标识符，一般是项目名称\n\n{% asset_img spring_boot_第一篇-1.jpg 项目结构 第二步 %}\n\n### 选择需要的包\n\n![第三步](https://image.battcn.com/article/images/20180420/springboot/v2-Introducing/4.png))\n\n默认生成的Spring Boot项目；\n\n- 主程序已经生成好了，我们只需要我们自己的逻辑\n- resources文件夹中目录结构\n  - static：保存所有的静态资源； js css  images；\n  - templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\n  - application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；\n\n{% asset_img spring_boot_第一篇-2.jpg 项目结构 %}\n\n### pom 文件 \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <!--版本采用的是最新的 2.1.6 RELEASE TODO 开发中请记得版本一定要选择 RELEASE 哦 -->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.6.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.shawn</groupId>\n    <artifactId>chapter1</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>chapter1</name>\n    <description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t\t<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<!-- 测试包,当我们使用 mvn package 的时候该包并不会被打入,因为它的生命周期只在 test 之内-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<!-- 编译插件 -->\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n\n</project>\n```\n\n### 主程序类\n\n@**SpringBootApplication**:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\n```java\npackage com.shawn.chapter1;\n\n\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Arrays;\n\n@RestController\n@SpringBootApplication\npublic class Chapter1Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Chapter1Application.class, args);\n    }\n\n    @GetMapping(\"demo1\")\n    public String demo1(){\n        return \"hello shawn\";\n    }\n\n}\n```\n\n### 依赖注解\n\n{% asset_img spring_boot_第一篇-3.jpg 项目结构 第二步 SpringBootApplication 注解依赖 %}\n\n@**SpringBootConfiguration**:Spring Boot的配置类；\n\n​\t\t标注在某个类上，表示这是一个Spring Boot的配置类；\n\n​\t\t@**Configuration**:配置类上来标注这个注解；\n\n​\t\t\t配置类 -----  配置文件；配置类也是容器中的一个组件；@Component\n\n\n\n@**EnableAutoConfiguration**：开启自动配置功能；\n\n​\t\t以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n\n```java\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n```\n\n​        @**AutoConfigurationPackage**：自动配置包\n\n​\t\t@**Import**(AutoConfigurationPackages.Registrar.class)：\n\n​\t\tSpring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\n\n**将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器**\n\n​\t@**Import**(EnableAutoConfigurationImportSelector.class)；\n\n​\t\t给容器中导入组件？\n\n​\t\t**EnableAutoConfigurationImportSelector**：导入哪些组件的选择器；\n\n​\t\t将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n\n​\t\t会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；\t\t\n{% asset_img 搜狗截图20180129224104.png 自动配置类 %}\n\n有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n\n```java\n​SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader);\n```\n**Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；**以前我们需要自己配置的东西，自动配置类都帮我们；\n\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；\n\n## 相关资料\n\n\n[本文相关项目](https://github.com/ShawnJim/spring-boot-learning/tree/master/chapter1)","tags":["java","Spring","idea"],"categories":["SpringBoot"]},{"title":"使用hexo + gitpages + cloudStudio搭建博客系统","url":"/2019/04/09/使用hexo搭建博客系统/","content":">之前都是在CSDN撰写博客，近段时间看见一篇博客讲述说hexo + gitpages 可以免费搭建一个属于个人的博客，琢磨琢磨就开始搭建了，下面就记录下搭建过程。\n<!-- more -->\n\n## 环境介绍\n### hexo\n[Hexo](https://hexo.io/zh-cn/docs/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。  \n  \n\n### gitpages\n对于它相信大家一定不陌生，不过还是在这介绍一下吧。GitHub Pages 本用于介绍托管在 GitHub 的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。总之，github Pages可以被认为是用户编写的、托管在github上的静态网页。  \n  \n    \n\n### Clound Studio\n[CloudStudio](https://dev.tencent.com/help/doc/cloud-studio) 是基于浏览器的集成式开发环境（IDE），为开发者提供了一个永不间断的云端工作站。Cloud Studio 还具有一些特色功能，如一键环境切换、多人协同编辑、在线预览等等，可以帮助开发者完成各种应用的开发、编译与部署工作。   \n说人话就是一个云端的可供多人在线协作开发的一个IDE工具，用起来非常方便。  \n\n## 搭建流程\n### Cloud Studio\n#### 创建运行空间\n注册coding账号绑定腾讯云账号后进入Cloud Studio新建工作空间\n{% asset_img hexo-cloudstudio-1.png %}  \n\n+ 选好来源及运行环境 \n+ 绑定SSH key至git仓库  \n\n{% asset_img hexo-cloudstudio-2.png 绑定SSH Key%}\n搞定之后创建就ok\n### hexo\n#### 初始化环境\n进入空间首先就是敲命令了\n```\nhexo init <folder>\n```\n其中`<folder>`就是你想要创建的文件夹。  \nps:`<folder>`为空的话取当前的文件夹,前提是当前文件夹为空，否则会报错。\n![](https://dn-coding-net-production-pp.codehub.cn/eeff1c31-1770-4045-9f3e-7924d361dade.jpg ) \n执行完成后接着敲\n```\ncd <folder>\nnpm install\n```\n这两执行完后，基本的包结构也就创建好了\n#### 配置hexo \n在hexo根目录找到_config.yml文件,找到deploy项,修改如下（使用gitPage发布）：\n```\ndeploy:\n  type: git\n  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: [branch] #published\n  message: [message]\n```\n详细查看[Hexo官方文档](https://hexo.io/zh-cn/docs/deployment)\n  \n\n## 写作  \n\n### hexo\n#### 写文章\n你可以执行下列命令来创建一篇新文章。\n```\n$ hexo new [layout] <title>\n```\n您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。  \n详细查看[Hexo官方文档](https://hexo.io/zh-cn/docs/writing)\n  \n#### 生成博客\n写完 md 源文件后，我们需要 Hexo 帮忙生成静态文件，以便能在浏览器中看到渲染后最终的效果。\n执行生成文件命令：\n```\nhexo generate\n```\n或者其简写形式：\n```\nhexo g\n```\n终端执行命令后效果如下。目录中会多出一个 public 文件夹，刚才生成的文件都放在其中。  \n\n#### 部署博客\nHexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。\n```\nhexo deploy\n```\n或者其简写形式：\n```\nhexo d\n```\n生成+部署：\n```\nhexo d -g\n```\n\n## 访问\n### gitpages  \n\n#### 对部署的仓库设置pages\n进入git仓库页面中的Settings选项进行配置,配置如下：\n{% asset_img hexo-cloudstudio-3.png %}\n#### 域名解析CNAME\nyourname.github.io配置到域名解析中\n{% asset_img hexo-cloudstudio-4.png %}\n上图是使用coding+gitpages来区分国内国外两种环境所做的双托管配置,  \n正常来说只用配置一项然后解析线路类型选择默认就ok。\n#### 访问\n如果访问配置域名跳转到该页面的话,就代表博客已经大功告成了。。。\n![](https://dn-coding-net-production-pp.codehub.cn/cc04c804-9fec-44f8-89fe-c64604eb1351.jpg)\n\n\n  \n\n## 参考资料\n[hexo官方文档](https://hexo.io/zh-cn/)  \n[最快的 Hexo 博客搭建方法](https://blog.coding.net/blog/CS-Hexo)  \n[把搭建的Hexo关联Git](https://www.jianshu.com/p/330e0ae1ebd7)  \n[Hexo博客双线部署](https://www.jianshu.com/p/f4fa869a6cc7)\n\n","tags":["博客"],"categories":["hexo","随记"]},{"title":"Hello World","url":"/2018/06/07/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["hexo"],"categories":["hexo"]}]